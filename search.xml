<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线段树</title>
      <link href="/2025/10/20/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2025/10/20/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="用线段树来干什么？"><a href="#用线段树来干什么？" class="headerlink" title="用线段树来干什么？"></a>用线段树来干什么？</h2><p>线段树适用于维护<strong>区间信息</strong>。</p><p>它可以在 $\log{n}$ 的时间内实现 <strong>单点修改、区间修改、区间查询</strong> 等操作。</p><p>当题目出现区间时，应该想到线段树。</p><h2 id="怎么用线段树？"><a href="#怎么用线段树？" class="headerlink" title="怎么用线段树？"></a>怎么用线段树？</h2><p>对于一个线段树，我们需要考虑的东西只有两个 —— <strong>元素</strong> 和 <strong>操作</strong>。</p><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>元素就是线段树上的 <strong>节点</strong>，一个节点可能有很多个信息。例如，一个线段树上的节点，可能存储着 左边界、右边界、区间长度、区间最大值、区间和 这样的信息。</p><p>元素对应着线段树中的 $tr$ 数组。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作涉及三个方面：<strong>元素与元素之间的合并、标记与元素直接的合并、标记与标记之间的合并。</strong></p><p>标记就是指线段树中的 $tag$ 数组，即对<strong>子节点</strong>的延时操作，注意，是<strong>子节点</strong>。</p><p>接下来介绍推导操作的方法。</p><p>以 <a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2 - 洛谷</a> 为例，我们设每个元素所代表的区间和值为 $x$，父亲的乘法标记为 $k$，父亲的加法标记为 $b$。于是，一个元素真正所代表的区间和的值就是：$kx+b$。</p><h4 id="元素与元素之间应该如何合并呢？"><a href="#元素与元素之间应该如何合并呢？" class="headerlink" title="元素与元素之间应该如何合并呢？"></a>元素与元素之间应该如何合并呢？</h4><p>显然，$tr[u]=tr[lc]+tr[rc]$。</p><h4 id="标记与元素之间应该如何合并呢？"><a href="#标记与元素之间应该如何合并呢？" class="headerlink" title="标记与元素之间应该如何合并呢？"></a>标记与元素之间应该如何合并呢？</h4><p>首先，对于一个元素值 $x$，我们想要把它变为它真正的样子，即 $kx+b$。</p><p>我们需要先乘上 $k$，再加上 $b$。</p><h4 id="标记与标记之间应该如何合并呢？"><a href="#标记与标记之间应该如何合并呢？" class="headerlink" title="标记与标记之间应该如何合并呢？"></a>标记与标记之间应该如何合并呢？</h4><p>标记与标记的合并 与 标记与元素的合并 是有关联的。</p><p>因为，当一个元素与 父亲的标记 合并时，自己的标记也同时会受到影响。</p><p>我们设元素值为 $kx+b$，现在它要与父亲的标记合并。</p><p>根据刚才讲的顺序，我们先乘一个 $k’$，元素就变成了 $k’kx+k’b$。</p><p>其中，$k’k$ 是新的乘法标签，$k’b$ 是新的加法标签。</p><p>然后再加一个 $b’$，加法标签就变成了 $k’b+b’$。</p><p>推导标记与标记之间的合并时，把当前标记所代表的元素表示出来后，再合并，就可以看出标记之间的变化了。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/19/CSP-S%20%E8%80%83%E5%89%8D%E5%A4%A7%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/10/19/CSP-S%20%E8%80%83%E5%89%8D%E5%A4%A7%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CSP-S-考前大复习"><a href="#CSP-S-考前大复习" class="headerlink" title="CSP-S 考前大复习"></a>CSP-S 考前大复习</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>树状数组：每一个节点 $x$ 管辖的区间是 $[x,x-lowbit(x)+1]$。</p><p>线段树：不断给查询区间剥壳(mid拆分)，直到没有壳为止(如果是子集，直接返回)；懒标记表示，当前这一个节点已经修改过了，但它的左右儿子还没有修改过。</p><p>并查集：记得初始化，用于维护逻辑关系与连通性，想好集合里维护的是什么。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI 模板</title>
      <link href="/2025/10/16/OI%20%E6%A8%A1%E6%9D%BF/"/>
      <url>/2025/10/16/OI%20%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="OI-模板"><a href="#OI-模板" class="headerlink" title="OI 模板"></a>OI 模板</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并查集十分高效，每次查询和合并的时间复杂度都接近O(1)</span></span><br><span class="line"><span class="comment">但并查集很难实现删除点，若一道题需要删除点，要么不考虑并查集，要么离线处理，把删除变为添加。</span></span><br><span class="line"><span class="comment">但不使用启发式合并的并查集的find的操作可能退化到O(n)，反正写个启发式合并也废不了多少时间，干脆就写上吧。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[maxn];<span class="comment">//记录当前点的老大</span></span><br><span class="line"><span class="type">int</span> h[maxn];<span class="comment">//记录当前集合的点的个数，用于启发式合并</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]));&#125;<span class="comment">//查找x的老大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//启发式合并两个集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx==fy) <span class="keyword">return</span> ;<span class="comment">//同一集合不需要合并</span></span><br><span class="line">    <span class="keyword">if</span>(fx&lt;fy) <span class="built_in">swap</span>(fx,fy);<span class="comment">//小的集合的老大需要改变，这样find才最少</span></span><br><span class="line">    h[fx]+=h[fy];</span><br><span class="line">    fa[fy]=fx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始时每个点都是独立集合</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        h[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">merge</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)?<span class="string">&quot;Y\n&quot;</span>:<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">monotone_queue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,front=<span class="number">0</span>,rear=<span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">monotone_queue</span>(<span class="type">int</span> t)</span><br><span class="line">    &#123;</span><br><span class="line">        n=t;</span><br><span class="line">        q.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;rear&amp;&amp;a[x]&gt;a[q[rear<span class="number">-1</span>]]) rear--;</span><br><span class="line">        q[rear++]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[front]==x) front++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;front=<span class="number">0</span>,rear=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> q[front];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="function">monotone_queue <span class="title">q</span><span class="params">(n<span class="number">+10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> T=<span class="number">0</span>;T&lt;=<span class="number">1</span>;T++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=-a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>(i-k);</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T?a[q.<span class="built_in">top</span>()]:-a[q.<span class="built_in">top</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tree[x] 维护的是 [x-lowbit(x)+1,x] 这一个区间内的和。</span></span><br><span class="line"><span class="comment">因此查询时需要不断 -lowbit(x)，添加则可以看作查询的逆操作。</span></span><br><span class="line"><span class="comment">真优雅！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n<span class="number">+5</span>)</span>,<span class="title">tree</span><span class="params">(n<span class="number">+5</span>)</span>,<span class="title">a</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> lowbit=[](<span class="type">int</span> x)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> x&amp;-x;&#125;;</span><br><span class="line">    <span class="comment">// O(n) 建树小trick,tree[i] 维护的是 a[x-lowbit(x)+1,x] 这个区间和，前缀和优化。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) tree[i]=sum[i]-sum[i-<span class="built_in">lowbit</span>(i)];</span><br><span class="line">    <span class="keyword">auto</span> add=[&amp;](<span class="type">int</span> i,<span class="type">int</span> k)-&gt;<span class="type">void</span> &#123;<span class="keyword">for</span>(i;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tree[i]+=k;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> query=[&amp;](<span class="type">int</span> i)-&gt;<span class="type">int</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i;i;i-=<span class="built_in">lowbit</span>(i)) sum+=tree[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y,k;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">            <span class="built_in">add</span>(x,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先 LCA"></a>最近公共祖先 LCA</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> fa[maxn][<span class="number">20</span>],dep[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span> ;</span><br><span class="line">        dep[v]=dep[u]<span class="number">+1</span>;</span><br><span class="line">        fa[v][<span class="number">0</span>]=u;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="type">int</span> k=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//提至同一层</span></span><br><span class="line">        <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>) u=fa[u][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            u=fa[u][i];</span><br><span class="line">            v=fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(u,v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">欧拉筛法的时间复杂度是线性的。</span></span><br><span class="line"><span class="comment">它的核心思想：</span></span><br><span class="line"><span class="comment">对于每个合数，都会被它的最小质因数筛掉。</span></span><br><span class="line"><span class="comment">它的实现过程：</span></span><br><span class="line"><span class="comment">通过合数i与质数primes[j]的乘积来去除合数。</span></span><br><span class="line"><span class="comment">当 i%primes[j]==0 时，直接break 。</span></span><br><span class="line"><span class="comment">这是因为，当i%primes[j]==0的时候，i*primes[j]的最小质因数是primes[j]，此时i中也包含primes[j]。</span></span><br><span class="line"><span class="comment">而当j++之后，i*primes[j] 的最小质因数就不是 primes[j]了，而是 i 当中包含的 primes[j-1]。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e8</span><span class="number">+10</span>,maxp=<span class="number">1e8</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//范围</span></span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//素数下标</span></span><br><span class="line"><span class="type">int</span> primes[maxp];<span class="comment">//记录有哪些素数</span></span><br><span class="line"><span class="type">bool</span> isPrime[maxn];<span class="comment">//标记是否为素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eular</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[i]) primes[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;primes[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            isPrime[i*primes[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">eular</span>(n);</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//询问第k小的素数是什么</span></span><br><span class="line">    <span class="type">int</span> q;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,primes[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧几里得算法-GCD"><a href="#欧几里得算法-GCD" class="headerlink" title="欧几里得算法 GCD"></a>欧几里得算法 GCD</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">gcd</span>(a,b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法-EXGCD"><a href="#扩展欧几里得算法-EXGCD" class="headerlink" title="扩展欧几里得算法 EXGCD"></a>扩展欧几里得算法 EXGCD</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,p;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">exgcd(a,b,x,y) 表示 ax+by=gcd(a,b)</span></span><br><span class="line"><span class="comment">当 b 是质数时，式子就变为：ax+by=1</span></span><br><span class="line"><span class="comment">此时等号两边都 mod b</span></span><br><span class="line"><span class="comment">即 ax ≡ 1 (mod b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exgcd</span>(b,a%b,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求逆元</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">exgcd</span>(i,p,x,y);</span><br><span class="line">        x=(x%p+p)%p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上背包</title>
      <link href="/2025/10/13/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85/"/>
      <url>/2025/10/13/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h1><p>参考文献：<a href="https://oi-wiki.org/dp/tree/#%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85">树形 DP - OI Wiki</a>。</p><p>树上背包就是在 树形dp 的基础上加了 背包dp。</p><p>和 线性背包 最大的区别在于：</p><ul><li><p>线性背包：选/不选 这个物品。</p></li><li><p>树上背包：给这个子树分配多少重量。</p></li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997] 选课 - 洛谷</a>。</p><p>每一个课程有一个先修课，可以联想到树上的结点只有一个父亲。</p><p>给没有先修课的结点加上一个先修课 $0$，这样我们就建了一颗树。</p><p>接下来给出树形dp的模板。</p><p>设 $f_{u,i,j}$ 表示：以 $u$ 为根，已经合并了 $i$ 个子树，一共用了 $j$ 个课程的最大学分。</p><p>因此我们可以给出转移：$f_{u,i,j}=\max_{\ k\leq \min(j,sz_v)}f_{u,i-1,j-k}+f_{v,sz_v,k}$ </p><p>不难看出，$i$ 这一维可以用滚动数组滚掉，只不过 $i和j$ 都要从大到小枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">G</span>(n<span class="number">+5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;cin&gt;&gt;u&gt;&gt;a[i];</span><br><span class="line">        G[u].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+5</span>,-INF));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sz</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> u)-&gt;<span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        sz[u]++;</span><br><span class="line">        f[u][<span class="number">1</span>]=a[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">self</span>(self,v);</span><br><span class="line">            sz[u]+=sz[v];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(sz[u],m);j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">min</span>(j,sz[v]);k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[u][j]=<span class="built_in">max</span>(f[u][j],f[u][j-k]+f[v][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;f[<span class="number">0</span>][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数的整除性</title>
      <link href="/2025/10/13/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B4%E9%99%A4%E6%80%A7/"/>
      <url>/2025/10/13/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B4%E9%99%A4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="判断一个数的整除性"><a href="#判断一个数的整除性" class="headerlink" title="判断一个数的整除性"></a>判断一个数的整除性</h1><p>记于 2025.10.13，从老师那得到了一个判断数整除性的方法，故收纳。</p><p>首先，对于任意一个十进制数 $n$，我们可以把它表示为：$d^m10^{m-1}+d^{m-1}10^{m-2}+……+d^110^0$。</p><h2 id="被-3-整除"><a href="#被-3-整除" class="headerlink" title="被 3 整除"></a>被 3 整除</h2><p>我们需要判断 $n$ 能否被 $3$ 整除。也就是求  $n\ mod\ 3$。</p><p>也就是：$(d^m10^{m-1}+d^{m-1}10^{m-2}+……+d^110^0)\ mod\ 3$</p><p>上式等于：$(d^m(10^{m-1}\ mod\ 3)+d^{m-1}(10^{m-2}\ mod\ 3)+……+d^1(10^0\ mod\ 3))\ mod\ 3$</p><p>又因为：$10^k\ mod\ 3 \equiv 1$。</p><p>因此可得：$(d^m+d^{m-1}+……+d^1)\ mod\ 3 = n\ mod\ 3$。</p><p>所以数位和为 $3$ 的倍数的数可以被 $3$ 整除。</p><h2 id="被-5-整除"><a href="#被-5-整除" class="headerlink" title="被 5 整除"></a>被 5 整除</h2><p>同样地，因为 $10^k\ mod\ 5\equiv0$，所以整个式子只剩下最后一位：$d^1$。</p><p>因此，$d^1\ mod\ 5=n\ mod\ 5$。</p><p>所以末尾是 $0$ 或 $5$ 的数能被 $5$ 整除。</p><h2 id="被-7-整除"><a href="#被-7-整除" class="headerlink" title="被 7 整除"></a>被 7 整除</h2><p>同样地，因为 $10^k\ mod\ 7\equiv [1,3,2,6,4,5]循环$</p><p>所以当一个数的数位都相同时，要判断这个数能否被 $7$ 整除，就要判断它是否是一个六位数（一个循环节加起来可以被 $7$ 整除）。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/CF2043B?contestId=283051">CF2043B Digits - 洛谷</a>。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI trick 汇总</title>
      <link href="/2025/10/09/OI%20trick%20%E6%B1%87%E6%80%BB/"/>
      <url>/2025/10/09/OI%20trick%20%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="OI-trick-汇总"><a href="#OI-trick-汇总" class="headerlink" title="OI trick 汇总"></a>OI trick 汇总</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OI 中的 trick 繁多，然而如果没有见过某个 trick 就很难切出那道题。因此，笔者收录了自己所见识到的 trick，方便自己查阅的同时方便大众。然而本人实力水平有限，必定会有遗漏，请见谅。</p><h2 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h2><ol><li><p>启发式合并：可用于解决多个不重集合的合并问题。时间复杂度是 $O(n\log{n}\times(数据结构插入复杂度)$ 的。例题：<a href="https://www.luogu.com.cn/problem/AT_abc372_e?contestId=281215">AT_abc372_e [ABC372E] K-th Largest Connected Components - 洛谷</a>，<a href="https://www.luogu.com.cn/problem/U41492?contestId=281215">U41492 树上数颜色 - 洛谷</a>，<a href="https://www.luogu.com.cn/problem/CF600E?contestId=281215">CF600E Lomsat gelral - 洛谷</a>，<a href="https://www.luogu.com.cn/problem/CF1009F?contestId=281215">CF1009F Dominant Indices - 洛谷</a>。</p></li><li><p>虚树。例题：<a href="https://www.luogu.com.cn/problem/P2495?contestId=281215">P2495 [SDOI2011] 消耗战 /【模板】虚树 - 洛谷</a>。</p></li><li><p>虚点。当多个点之间相互连接，且边权相同时，可以将它们都连向一个虚点，边权为原边权/2。这样就可以以 O(1) 的时间复杂添加或删除一个点啦。例题：<a href="https://www.luogu.com.cn/problem/AT_abc416_e">AT_abc416_e [ABC416E] Development - 洛谷</a>。</p></li><li><p>双向搜索。例题：<a href="https://www.luogu.com.cn/problem/P2962?contestId=281370">P2962 [USACO09NOV] Lights G - 洛谷</a>。</p></li><li><p>当你要进行一系列运算求最大值，并且运算中带有乘法时，既要维护最大值，也要维护最小值。例题：<a href="https://www.luogu.com.cn/problem/P4342?contestId=281695">P4342 [IOI 1998] Polygon - 洛谷</a>。</p></li><li><p>扩环成链。</p></li><li><p>$O(n)$ 给树状数组建树：<a href="https://oi-wiki.org/ds/fenwick/#thetan-%E5%BB%BA%E6%A0%91">树状数组 - OI Wiki</a>。</p></li><li><p>求 $[l,r]$ 中平方数的数量，转化为求 $[0,r]$ 中平方数的数量，也就是 $\lfloor\sqrt{r}\rfloor$。所以根据前缀和的思想，原问题的解就是：$\lfloor\sqrt{r}\rfloor-\lfloor\sqrt{l-1}\rfloor$：<a href="https://atcoder.jp/contests/abc428/tasks/abc428_d">D - 183184</a></p></li><li><p>当要判断一个字符串中两种字符数量是否相等时，可以把它们分别转化为 $1$ 和 $-1$，这样前缀和累加起来，结果是 $0$ 的话就相等。括号匹配同理，不过要保证加的过程中不能小于 $0$.</p></li><li><p>删除序列中的某个数，使得序列中不存在相邻的数，这个问题可以用 $dp$ 求解。设 <code>dp[i][0/1]</code> 表示前 i 个数满足条件，且删或不删第 $i$ 个数所需的最少操作数。</p></li><li><p>当数学公式里出现 $\max$ 或 $\min$ 时，可以想想对答案有贡献的成分是哪些。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2025/09/25/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2025/09/25/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="常用运算优先级"><a href="#常用运算优先级" class="headerlink" title="常用运算优先级"></a>常用运算优先级</h2><p>(按由高到低排序，编号越小优先级越高)</p><ol><li><p><code>!,~</code></p></li><li><p><code>+,-</code></p></li><li><p><code>&lt;&lt;,&gt;&gt;</code></p></li><li><p><code>&lt;,&lt;=,&gt;,&gt;=,==,!=</code></p></li><li><p><code>&amp;</code></p></li><li><p><code>^</code></p></li><li><p><code>|</code></p></li><li><p><code>&amp;&amp;</code></p></li><li><p><code>||</code></p></li><li><p>赋值运算符</p></li></ol><h2 id="神秘位运算"><a href="#神秘位运算" class="headerlink" title="神秘位运算"></a>神秘位运算</h2><ul><li><p>将某一位设置为 1：<code>u|=1&lt;&lt;x;</code></p></li><li><p>将某一位设置为 0：<code>u&amp;=~(1&lt;&lt;x);</code></p></li><li><p>取出某一位的值：<code>u&gt;&gt;x&amp;1</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状压dp</title>
      <link href="/2025/09/25/%E7%8A%B6%E5%8E%8Bdp/"/>
      <url>/2025/09/25/%E7%8A%B6%E5%8E%8Bdp/</url>
      
        <content type="html"><![CDATA[<h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><p>前置知识：位运算。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用二进制来表示状态的dp，就是状压dp。</p><p>这就是状压dp的全部了，现在可以开始愉快地切题啦！</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P10447?contestId=250215">P10447 最短 Hamilton 路径 - 洛谷</a>。</p><h3 id="最短-Hamilton-路径"><a href="#最短-Hamilton-路径" class="headerlink" title="最短 Hamilton 路径"></a>最短 Hamilton 路径</h3><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>连通带权无向图，求不重不漏经过每个点，从顶点 $0$ 到顶点 $n-1$，最少花费。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li>$1\leq N \leq 20$</li></ul><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>图上求最少花费，首先想到最短路。</p><p>然而最短路无法</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2025/09/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/09/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种用于维护元素所属集合的数据结构。集合所代表的意义<strong>十分灵活</strong>，但通常都是在维护<strong>连通性</strong> 与 <strong>可行性</strong>。</p><p>思考并查集的集合维护什么，<strong>是非常关键的。</strong></p><p>一定要想好集合的含义再写题，就像写动态规划之前一定要明确好状态一样重要。</p><p>一定要记得初始化！</p><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p>当并查集的集合维护的是一种逻辑关系时，普通并查集可能处理不了复杂的关系。</p><p>这个时候就需要<strong>扩展域并查集</strong>。</p><p>扩展域并查集是用于维护复杂的逻辑关系的。因此，扩展域并查集的集合所维护的内容大概率也是某种逻辑关系。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li><p><a href="https://www.luogu.com.cn/problem/P1892">P1892 [BalticOI 2003] 团伙 - 洛谷</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1525">P1525 [NOIP 2010 提高组] 关押罪犯 - 洛谷</a></p></li><li><p><a href="https://codeforces.com/problemset/problem/776/D">776D The Door Problem - Codeforces</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2024">P2024 [NOI2001] 食物链 - 洛谷</a></p></li></ol><h3 id="团伙"><a href="#团伙" class="headerlink" title="团伙"></a>团伙</h3><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>朋友的朋友是朋友，敌人的敌人是朋友。现有 $N$ 个人与 $M$ 组关系，当且仅当两个人是朋友的时候才能构成一个团伙，求团伙数量。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li><p>$2\leq N \leq 1000$</p></li><li><p>$1\leq M \leq 5000$</p></li></ul><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>需要维护逻辑复杂的逻辑关系，且只有合并集合没有删除集合，多么完美的扩展域并查集版子题！</p><p>定义 $fa[i]$ 表示：第 $i$ 个人所属的团伙。</p><p>定义 $fa[i+n]$ 表示：第 $i$ 个人的相反状态所属的团伙。</p><p>如果 $u$ 和 $v$ 是敌人，则说明 $u$ 和 $v+n$ 是朋友，且 $v$ 和 $u+n$ 也是朋友。</p><p>对于每个 $fa[i]$ 的初始值，都设为 $i$。</p><p>对于每个操作，如果是朋友，则合并 $u$ 和 $v$。</p><p>如果是敌人，则合并 $v$ 和 $v+n$，$u$ 和 $v+n$。</p><p>最后输出不同的团伙数量即可。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[maxn*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;<span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[<span class="built_in">find</span>(u)]=<span class="built_in">find</span>(v+n);</span><br><span class="line">            fa[<span class="built_in">find</span>(v)]=<span class="built_in">find</span>(u+n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> fa[<span class="built_in">find</span>(u)]=<span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt.<span class="built_in">insert</span>(<span class="built_in">find</span>(i));</span><br><span class="line">    cout&lt;&lt;cnt.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关押罪犯"><a href="#关押罪犯" class="headerlink" title="关押罪犯"></a>关押罪犯</h3><h4 id="题意简述-1"><a href="#题意简述-1" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定 $N$ 个罪犯和 $M$ 组敌对关系，现有两座监狱。</p><p>如果有敌对关系的两人处于同一所监狱，则会爆发强度为 $C$ 的冲突。</p><p>如果没有爆发冲突，输出 $0$。</p><p>求最小爆发冲突强度。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq N\leq 2\times 10^4$</p><p>$1\leq M \leq 10^5$</p><h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>同样地，维护敌对关系，且只有合并没有删除，十分明显的扩展域并查集。</p><p>要使得冲突最小，就让 $C$ 从大到小排序，先解决冲突大地两个罪犯。</p><p>定义 $fa[i]$ 表示：第 $i$ 个罪犯所处的监狱的罪犯集合。</p><p>定义 $fa[i+n]$ 表示：第 $i$ 个罪犯的相反状态所处的监狱的罪犯集合。</p><p>如果两个罪犯有敌对关系，那么就合并 $u$ 和 $v+n$，$v$ 和 $u+n$。</p><p>如果两个罪罚有敌对关系，且 $u$ 与 $v$ 处于一个监狱的罪犯集合，那么就会爆发冲突。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e4</span><span class="number">+10</span>,maxm=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn*<span class="number">2</span>];<span class="comment">// fa[i] 维护第i个罪犯所处的监狱的罪犯集合。</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">relation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> relation&amp; t) <span class="type">const</span> &#123;<span class="keyword">return</span> c&gt;t.c;&#125;</span><br><span class="line">&#125;r[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;r[i].u&gt;&gt;r[i].v&gt;&gt;r[i].c;</span><br><span class="line">    <span class="built_in">sort</span>(r<span class="number">+1</span>,r<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=r[i].u,v=r[i].v,c=r[i].c;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;c;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[<span class="built_in">find</span>(u)]=<span class="built_in">find</span>(v+n);</span><br><span class="line">        fa[<span class="built_in">find</span>(v)]=<span class="built_in">find</span>(u+n);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Door-Problem"><a href="#The-Door-Problem" class="headerlink" title="The Door Problem"></a>The Door Problem</h3><h4 id="题意简述-2"><a href="#题意简述-2" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定 $N$ 扇门和 $M$ 把钥匙，每把钥匙同时控制 $K_i$ 扇门，且每扇门都被两把钥匙控制。</p><p>给定门的初始状态，$0$ 表示关，$1$ 表示开。</p><p>求是否能将门全部打开，可以输出 <code>YES</code>，不可以输出 <code>NO</code>。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>$2\leq N,M\leq 2\times 10^5$</p><h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>问题要求判断可行性，且这个时间复杂度抓得非常严，所以很自然的考虑解决这类问题的专家——并查集。</p><p>题目的一个信息很有趣：“每扇门都被两把钥匙控制”。</p><p>因此，我们根据这个性质来突破。</p><p>分类讨论门的初始状态。</p><p>设 $u$ 和 $v$ 是控制第 $k$ 个门的两把钥匙。</p><p>如果门初始时关闭，那么为了使它打开，就要使用 $u$ 且不使用 $v$，或者使用 $v$ 且不使用 $u$。</p><p>如果门初始时打开，那么为了使它打开，就要同时使用 $u$ 和 $v$，或者同时不使用 $v$ 和 $v$。</p><p>此时一把钥匙拥有两种状态——使用与不使用。所以考虑扩展域并查集。</p><p>如果 $i$ 和 $i+n$ 处于同一集合内，则不可行。</p><p>所以可以推导出，集合内存储的是钥匙使用的情况。</p><p>定义 $fa[i]$ 表示：要使用钥匙 $i$，就必须使用的钥匙集合。</p><p>定义 $fa[i+n]$ 表示：不使用钥匙 $i$，就必须使用的钥匙集合。</p><p>如果门初始为关闭，就合并 $u$ 和 $v+n$，$v$ 和 $u+n$。</p><p>如果门初始为打开，就合并 $u$ 和 $v$，$u+n$，$v+n$。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn*<span class="number">2</span>];<span class="comment">// fa[i] 表示要使用钥匙 i，就必须使用的钥匙集合。</span></span><br><span class="line"><span class="type">int</span> n,m,a[maxn];</span><br><span class="line"><span class="type">int</span> cnt[maxn];<span class="comment">// cnt[i] 表示第 i 扇门，已经统计了几把钥匙</span></span><br><span class="line"><span class="type">int</span> key[maxn][<span class="number">2</span>];<span class="comment">// key[x][0/1] 表示第 x 扇门，对应的第 0/1 把钥匙是什么</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;cin&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">            key[x][cnt[x]++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=key[i][<span class="number">0</span>],v=key[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[<span class="built_in">find</span>(u)]=<span class="built_in">find</span>(v+m);</span><br><span class="line">            fa[<span class="built_in">find</span>(v)]=<span class="built_in">find</span>(u+m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fa[<span class="built_in">find</span>(u)]=<span class="built_in">find</span>(v);</span><br><span class="line">            fa[<span class="built_in">find</span>(u+m)]=<span class="built_in">find</span>(v+m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(u+m)||<span class="built_in">find</span>(v)==<span class="built_in">find</span>(v+m))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><h4 id="题意简述-3"><a href="#题意简述-3" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定 $N$ 个动物，每个动物属于 $A,B,C$ 中的一种。且 $A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。</p><p>有 $M$ 句话，当这句话满足以下条件任意之一时，它是假话。</p><ul><li><p>它违反了之前的真话</p></li><li><p>$X$ 或 $Y$ 大于 $N$</p></li><li><p>$X$ 吃 $X$</p></li></ul><p>统计假话数量。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq N \leq 5\times 10^4$</p><p>$1\leq M \leq 10^5$</p><h4 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先本题的难点在于判断“它是否违反了之前的真话”。</p><p>这是一个判断可行性的问题，且每个动物都有多种可能状态，$A$ 或 $B$ 或 $C$。</p><p>再加上时间复杂度压得很严，所以想到扩展域并查集。</p><p>定义：</p><p>$fa[i]$ 表示：吃掉第 $i$ 只动物的动物 的同类。</p><p>$fa[i+n]$ 表示：第 $i$ 只动物的同类。</p><p>$fa[i+2n]$ 表示：第 $i$ 只动物吃掉的动物 的同类。</p><p>给定 $X$ 和 $Y$ 两只动物。</p><p>如果 $X$ 与 $Y$ 是<strong>同类</strong>：</p><p>那么当以下条件任意一个满足时，这句话是假话：</p><ul><li><p>$Y$ 吃 $X$。</p></li><li><p>$X$ 吃 $Y$。</p></li></ul><p>否则，就合并 $x$ 和 $y$，$x+n$ 和 $y+n$，$x+2n$ 和 $y+2n$。</p><p>如果 $X$ 吃 $Y$：</p><p>那么当以下条件任意一个满足时，这句话是假话：</p><ul><li><p>$X$ 与 $Y$ 是同类。</p></li><li><p>$Y$ 吃 $X$。</p><p>否则，就合并 $x$ 与 $y+2n$，$x+n$ 和 $y$，$x+2n$ 与 $y+n$。</p></li></ul><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO &#123;cnt++;continue ;&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> fa[maxn*<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;n||y&gt;n) <span class="function">NO</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(op==<span class="number">2</span>&amp;&amp;x==y)</span> NO</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(op==<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y+n)||<span class="built_in">find</span>(x<span class="number">+2</span>*n)==<span class="built_in">find</span>(y+n)) NO</span><br><span class="line">            fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">            fa[<span class="built_in">find</span>(x+n)]=<span class="built_in">find</span>(y+n);</span><br><span class="line">            fa[<span class="built_in">find</span>(x<span class="number">+2</span>*n)]=<span class="built_in">find</span>(y<span class="number">+2</span>*n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x+n)==<span class="built_in">find</span>(y+n)||<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y+n)) NO</span><br><span class="line">            fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y<span class="number">+2</span>*n);</span><br><span class="line">            fa[<span class="built_in">find</span>(x+n)]=<span class="built_in">find</span>(y);</span><br><span class="line">            fa[<span class="built_in">find</span>(x<span class="number">+2</span>*n)]=<span class="built_in">find</span>(y+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 扩展域并查集 </tag>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][P1840] Color the Axis</title>
      <link href="/2025/08/31/%5B%E9%A2%98%E8%A7%A3%5D%5BP1840%5D%20Color%20the%20Axis/"/>
      <url>/2025/08/31/%5B%E9%A2%98%E8%A7%A3%5D%5BP1840%5D%20Color%20the%20Axis/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-P1840-Color-the-Axis"><a href="#题解-P1840-Color-the-Axis" class="headerlink" title="[题解][P1840] Color the Axis"></a>[题解][P1840] Color the Axis</h1><p>原题链接：<a href="https://www.luogu.com.cn/problem/P1840">P1840 Color the Axis - 洛谷</a>。</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>数轴上有 $N$ 个点，最初每个点是黑色。进行 $M$ 次操作，每次操作将 $[l,r]$ 区间内的点都染成白色，输出每次操作后的黑色点数量。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq N,M \leq 2\times 10^5$</p><p>$l,r \leq N$</p><p>大约是 $O(M\log N)$ 的时间复杂度吧。</p><h2 id="分析性质"><a href="#分析性质" class="headerlink" title="分析性质"></a>分析性质</h2><p>首先不难想到暴力。每次枚举 $[l,r]$，但这样显然效率低下。</p><p>注意到已经染色的白色点是对答案<strong>没有贡献</strong>的，我们可以想一下能不能<strong>跳过</strong>这些白色点。</p><p>因此我们用一个数组 $black[i]$ 来记录<strong>大于等于</strong> $i$ 点的第一个黑色点。</p><p>每次操作从依然是遍历 $[l,r]$。</p><p>如果我们遇到的是黑色点（即 $black[l]=l$），那就将 $black[l]$ 设置为 $black[r+1]$，将 $l+1$。</p><p>如果我们遇到的是白色点（即 $black[l]\not =l)$，那就将 $l$ 设置为 $black[l]$。</p><p>但我们发现一个问题，如果我们修改了 $black[r+1]$ 这个值，那么指向它的值也会收到变化，因此我们要有一个“求根知底”的函数 $find$。</p><p>但很多人认为这题是一个并查集，在我看来只是一个优化的小技巧而已。虽然有涉及到并查集的 $find$ 函数，但并没有合并集合的操作，甚至没有集合的概念。所以我认为本题不能算作并查集。</p><p>时间复杂度 $O(N+M)$，快的飞起。</p><h2 id="方法提炼"><a href="#方法提炼" class="headerlink" title="方法提炼"></a>方法提炼</h2><p>对答案没有贡献的点，直接跳过！</p><p>将一个区间内的值全部删除，要联想到本题。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> black[maxn];<span class="comment">//大于等于当前点的黑色点。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//找到大于等于当前点的第一个黑色点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span> n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(black[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> black[x]=<span class="built_in">find</span>(black[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) black[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l=<span class="built_in">find</span>(l);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(black[l]==l)</span><br><span class="line">            &#123;</span><br><span class="line">                black[l]=<span class="built_in">find</span>(r<span class="number">+1</span>);</span><br><span class="line">                l++;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l=<span class="built_in">find</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;n-cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC390E] Vitamin Balance</title>
      <link href="/2025/08/28/%5B%E9%A2%98%E8%A7%A3%5D%5BABC390E%5D%20Vitamin%20Balance/"/>
      <url>/2025/08/28/%5B%E9%A2%98%E8%A7%A3%5D%5BABC390E%5D%20Vitamin%20Balance/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC390E-Vitamin-Balance"><a href="#题解-ABC390E-Vitamin-Balance" class="headerlink" title="[题解][ABC390E] Vitamin Balance"></a>[题解][ABC390E] Vitamin Balance</h1><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>有 $N$ 件商品和 $X$ 元钱。每件商品有三个属性：组别 $V_i$，价值 $A_i$，价格 $C_i$。</p><p>一共只有三种组别。可以选择若干件商品，求 “价值最小的组别 的 价值最大值”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><ul><li><p>$1\leq N,X\leq5000$</p></li><li><p>$1\leq V_i\leq3$</p></li><li><p>$1\leq A_i\leq2 \times 10^5$</p></li></ul><p>输入均为整数。</p><p>应该是 $O(NX)$ 的时间复杂度。</p><h2 id="分析性质"><a href="#分析性质" class="headerlink" title="分析性质"></a>分析性质</h2><p>不难发现，在 $X$ 相同的情况下，每组的答案越大越好。</p><p>因此对每个组都 01背包 一下。时间复杂度大约 $O(NX)$。</p><p>然后枚举两个组别的花费，第三个组别的花费也能算出来。时间复杂度 $O(X^2)$。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">4</span>][maxn];</span><br><span class="line"><span class="type">int</span> n,m,ans,cnt[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">4</span>][maxn],v[<span class="number">4</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) ++cnt[<span class="number">1</span>],v[op][cnt[<span class="number">1</span>]]=x,w[op][cnt[<span class="number">1</span>]]=y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) ++cnt[<span class="number">2</span>],v[op][cnt[<span class="number">2</span>]]=x,w[op][cnt[<span class="number">2</span>]]=y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) ++cnt[<span class="number">3</span>],v[op][cnt[<span class="number">3</span>]]=x,w[op][cnt[<span class="number">3</span>]]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt[k];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[k][i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[k][j]=<span class="built_in">max</span>(dp[k][j],dp[k][j-w[k][i]]+v[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=m-i-j;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(<span class="built_in">min</span>(dp[<span class="number">1</span>][i],dp[<span class="number">2</span>][j]),dp[<span class="number">3</span>][k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC375E] 3 Team Division</title>
      <link href="/2025/08/27/%5B%E9%A2%98%E8%A7%A3%5D%5BABC375E%5D%203%20Team%20Division/"/>
      <url>/2025/08/27/%5B%E9%A2%98%E8%A7%A3%5D%5BABC375E%5D%203%20Team%20Division/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC375E-3-Team-Division"><a href="#题解-ABC375E-3-Team-Division" class="headerlink" title="[题解][ABC375E] 3 Team Division"></a>[题解][ABC375E] 3 Team Division</h1><p>原题链接：<a href="https://atcoder.jp/contests/abc375/tasks/abc375_e">E - 3 Team Division</a>。</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>将 $N$ 个人分成三个小组。每个人都有一个 “战力值” $B_i$，记每个小组的 “战斗力” 为小组中人的 “战力值” 之和。能否交换 $0$ 或若干个人，使得每个小组的 “战斗力” 相等？如果可以，输出最少交换几个人。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$3\leq N\leq100$</p><p>$\sum\limits_{i=1}^{N}B_i\leq1500$ </p><h2 id="分析性质"><a href="#分析性质" class="headerlink" title="分析性质"></a>分析性质</h2><p>题目的 $N$ 很小，$B_i$ 的总和也很小。正解的时间复杂度不好预测，但应该与 $B_i$ 有关。</p><p>题目需要使得 <code>三组的战斗力都相等</code>，因此设 $N$ 个人的战力值总和为 $sum$，则有如下性质：</p><ul><li><p>$3\mid sum$ </p></li><li><p>每组的战斗力为 $\frac{sum}{3}$</p></li></ul><h2 id="设计算法"><a href="#设计算法" class="headerlink" title="设计算法"></a>设计算法</h2><p>此时问题就转化为了：<strong>“使得每组的战斗力都为 $\frac{sum}{3}$ 的最小操作次数”</strong>。</p><p>最值问题，首先想到贪心、二分和动态规划。贪心假了，二分不行，那么应该就是<strong>动态规划</strong>了。</p><p>数据范围给的很小，我们直接根据问题设置 dp 数组(也就是状态)：</p><p>设 $dp[i][j][k][l]$ 表示：前 $i$ 个人已经分好组，第一组的战斗力为 $j$，第二组的战斗力为 $k$，第三组的战斗力为 $l$ 的情况下，所需要的<strong>最小操作次数</strong>。</p><p>此时空间的开销是：$100\times500^3=12500000000=1.25\times10^8$</p><p>而 $C++$ 整型最多可以开到大约 $3\times10^7$ 的空间，显然不够。</p><p>重新定义状态 $dp[i][j][k]$ 表示：前 $i$ 个人已经分好组，第一组的战斗力为 $j$，第二组的战斗力为 $k$ 的情况下所需要的<strong>最小操作次数</strong>。</p><p>接下来推导 $dp$ 的动态转移方程。</p><p>在状态 $dp[i][j][k]$ 中，$i$ 已经移动到了 <code>第一</code> 或 <code>第二</code> 或<code>第三</code> 组中了，因此，我们分类讨论 $i$ 移动到了哪个组中：</p><ul><li><p>$i$ 被移动到了第 $1$ 组：$dp[i][j][k]= dp[i-1][j-B_i][k][l]+[i不是第1组的]$ </p></li><li><p>$i$ 被移动到了第 $2$ 组：$dp[i][j][k]= dp[i-1][j][k-B_i][l]+[i不是第2组的]$</p></li><li><p>$i$ 被移动到了第 $3$ 组：$dp[i][j][k]= dp[i-1][j][k]+[i不是第3组的]$</p></li></ul><p>然后边界就是：$dp[0][0][0]=0$</p><h2 id="方法提炼"><a href="#方法提炼" class="headerlink" title="方法提炼"></a>方法提炼</h2><p>大胆设状态啊。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">110</span>,maxa=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxa][maxa];</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="type">int</span> n,sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        sum+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;s+=b[i],i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sum/<span class="number">3</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=sum/<span class="number">3</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j-b[i]&gt;=<span class="number">0</span>) dp[i][j][k]=<span class="built_in">min</span>(dp[i][j][k],dp[i<span class="number">-1</span>][j-b[i]][k]+(a[i]!=<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(k-b[i]&gt;=<span class="number">0</span>) dp[i][j][k]=<span class="built_in">min</span>(dp[i][j][k],dp[i<span class="number">-1</span>][j][k-b[i]]+(a[i]!=<span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span>(s-j-k-b[i]&gt;=<span class="number">0</span>) dp[i][j][k]=<span class="built_in">min</span>(dp[i][j][k],dp[i<span class="number">-1</span>][j][k]+(a[i]!=<span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> ans=dp[n][sum/<span class="number">3</span>][sum/<span class="number">3</span>];</span><br><span class="line">    cout&lt;&lt;(ans==<span class="number">0x3f3f3f3f</span>?<span class="number">-1</span>:ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC393E] GCD of Subset</title>
      <link href="/2025/08/26/%5B%E9%A2%98%E8%A7%A3%5D%5BABC393E%5D%20GCD%20of%20Subset/"/>
      <url>/2025/08/26/%5B%E9%A2%98%E8%A7%A3%5D%5BABC393E%5D%20GCD%20of%20Subset/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC393E-GCD-of-Subset"><a href="#题解-ABC393E-GCD-of-Subset" class="headerlink" title="[题解][ABC393E] GCD of Subset"></a>[题解][ABC393E] GCD of Subset</h1><p>原题链接：<a href="https://atcoder.jp/contests/abc393/tasks/abc393_e">E - GCD of Subset</a></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给定一个长度为 $N$ 的序列 $A$，在 $A$ 中选 $K$ 个数求 <code>gcd</code>，其中一定要包含第 $A_i$ 个数 $(1\leq i \leq N)$，求 <code>gcd</code> 最大值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq N\leq 1.2\times10^6$</p><p>$1\leq A_i\leq10^6$</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先注意到 $A_i$ 的值域很小，引导我们往枚举答案的方面上想。</p><p>分析一下正解复杂度，应该是 $线性\times单\log$。</p><p>但奈何 <code>gcd</code> 的性质实在是少，此时我们就可以把<strong>答案设出来</strong>，<strong>分析</strong>答案的<strong>性质</strong>，再<strong>反推</strong>答案。</p><p>对于每一个 $A_i$，设其答案为 $d$，则 $d$ 满足以下性质。</p><ul><li><p>$d\mid A_i$ </p></li><li><p>在 $A$ 中有<strong>至少</strong> $k$ 个数可以<strong>整除</strong> $d$</p></li></ul><p>我们根据 <code>性质2</code> 反推答案。</p><p>如果一个数 $x$ 满足 <code>性质2</code>，则 $x$ 就<strong>可以</strong>作为它所有<strong>倍数</strong>的<strong>答案</strong>。 </p><p>且 $x$ 的范围很小，可以<strong>枚举</strong>。只要从<strong>大到小</strong>枚举 $x$，并且保证每个数的答案只被最大的 $x$ 更新就好啦。这一步的时间复杂度是 $O(V\log V)$ 的，可以接受。</p><p>现在的问题就变成了，如何计算 “$x$ 被 $A$ 中的多少个数整除”。</p><p>正着说，也就是求 “$A$ 中有多少个数是 $x$ 的<strong>倍数</strong>“。</p><p>直接<strong>枚举</strong> $x$ 和它的倍数就好啦，用一个<strong>桶</strong>记录 $A$ 中某数出现的次数，累加。</p><p>这一步的时间复杂度是 $O(V\log V)$ 的，可以接受。</p><h2 id="方法提炼"><a href="#方法提炼" class="headerlink" title="方法提炼"></a>方法提炼</h2><ol><li><p>当题目的信息不够用时，可以把答案设出来，再分析答案的性质，根据性质反推答案。</p></li><li><p>善于利用出题者在数据范围中设置的提示。</p></li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1.2e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxa=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],cnt[maxa],mul[maxa],ans[maxn];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[a[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxa;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;maxa;j+=i)</span><br><span class="line">            mul[i]+=cnt[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d=maxa;d&gt;=<span class="number">1</span>;d--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mul[d]&lt;k) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=d;j&lt;maxa;j+=d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[j]) <span class="keyword">continue</span> ;</span><br><span class="line">            ans[j]=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[a[i]]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说 <code>cin</code> 关同步流真好用。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC395D] Pigeon Swap</title>
      <link href="/2025/08/26/%5B%E9%A2%98%E8%A7%A3%5D%5BABC395D%5D%20Pigeon%20Swap/"/>
      <url>/2025/08/26/%5B%E9%A2%98%E8%A7%A3%5D%5BABC395D%5D%20Pigeon%20Swap/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC395D-Pigeon-Swap"><a href="#题解-ABC395D-Pigeon-Swap" class="headerlink" title="[题解][ABC395D] Pigeon Swap"></a>[题解][ABC395D] Pigeon Swap</h1><p>原题链接：<a href="https://atcoder.jp/contests/abc395/tasks/abc395_d">D - Pigeon Swap</a></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>有 $N$ 只鸽子和 $N$ 个鸽巢，最初，鸽子 $i$ 位于鸽巢 $i$ 中。</p><p>然后进行 $Q$ 次操作。对于每次操作，有三种类型。</p><ol><li><p>将编号为 $a$ 的鸽子移动到鸽巢 $b$ 中。</p></li><li><p>将鸽巢 $a$ 中的所有鸽子与鸽巢 $b$ 中的所有鸽子交换。</p></li><li><p>输出编号 $a$ 的鸽子处于哪个鸽巢。</p></li></ol><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>为了完成 <code>操作1</code>，我们需要一个 $g[i]$ 数组存储：编号为 $i$ 的<strong>鸽子</strong>所处的鸽巢<strong>编号</strong>。代码即</p><blockquote><p> g[a]=b </p></blockquote><p>但这样的缺点很显然，在执行 <code>操作2</code> 时，需要用到 $O(n)$ 的时间复杂度，这是不被本题数据范围所接受的。</p><p>我们又想到，交换 <code>鸽巢里的鸽子</code> 就相当于 <code>交换鸽巢</code>。我们把 $a$ 和 $b$ 鸽子所对应的鸽巢交换，就可以达到 <code>操作2</code> 的效果。</p><p>因此，我们设置一个数组 $c[i]$ 表示：编号为 $i$ 的<strong>鸽巢</strong>所对应的<strong>真正</strong>鸽巢。代码即</p><blockquote><p>c[a]=b; c[b]=a;</p></blockquote><p>最后输出的代码即</p><blockquote><p>cout&lt;&lt;c[g[a]];</p></blockquote><p>结束了？并非。我们在添加一个新东西时，要看看它与旧东西是否冲突。</p><p>我们最后输出的是 <code>c[g[a]]</code>，也就是说，如果我们执行 <code>操作1</code> ，<code>c[g[a]]</code> 的值应该是 $b$。那么 <code>g[a]</code> 的值就应该是 <code>真正的鸽巢 b 所对应的鸽巢编号</code>。所以我们还需要一个数组 <code>p[i]</code> 表示：真正的鸽巢 $i$ 所对应的鸽巢编号。</p><p>另外，注意题目给的是<strong>真正</strong>的鸽巢而不是鸽巢<strong>编号</strong>。</p><p>梳理一下，我们有如下数组</p><ul><li><p>$g[i]$：$i$ 号鸽子所对应的鸽巢<strong>编号</strong>。</p></li><li><p>$c[i]$：编号为 $i$ 的鸽巢所对应的<strong>真正</strong>的鸽巢。</p></li><li><p>$p[i]$：<strong>真正</strong>的鸽巢 $i$ 所对应的鸽巢<strong>编号</strong>。</p></li></ul><p>对于操作一，为满足定义，我们执行：<code>g[a]=p[b];</code></p><p>对于操作二，由于题目给的 $a$ 和 $b$ 是指<strong>真正</strong>的鸽巢，而我们是在交换鸽巢<strong>编号</strong>，所以我们执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(p[a],p[b]);<span class="comment">//交换编号</span></span><br><span class="line"><span class="built_in">swap</span>(c[p[a]],c[p[b]]);<span class="comment">//更新鸽巢编号为p[a]所指的真正鸽巢</span></span><br><span class="line"><span class="comment">//swap先后顺序不影响两个语句的顺序不固定</span></span><br></pre></td></tr></table></figure><p>对于操作三，我们输出：<code>c[g[a]]</code>。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> g[maxn],c[maxn],p[maxn];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i]=c[i]=p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,a,b;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            g[a]=p[b]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">swap</span>(p[a],p[b]);</span><br><span class="line">            <span class="built_in">swap</span>(c[p[a]],c[p[b]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            cout&lt;&lt;c[g[a]]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC397D] Cubes</title>
      <link href="/2025/08/25/%5B%E9%A2%98%E8%A7%A3%5D%5BABC397D%5D%20Cubes/"/>
      <url>/2025/08/25/%5B%E9%A2%98%E8%A7%A3%5D%5BABC397D%5D%20Cubes/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC397D-Cubes"><a href="#题解-ABC397D-Cubes" class="headerlink" title="[题解][ABC397D] Cubes"></a>[题解][ABC397D] Cubes</h1><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>求一组正整数 $(x,y)$ 使得 $x^3-y^3=N$ 。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><ul><li>$1\leq N\leq 10^{18}$ </li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>单看 $x^3-y^3=N$ 这个式子我们好像得不到什么信息，但其实这个式子是有很多隐藏约束的。</p><p>$\because 1\leq N$</p><p>$\therefore x^3&gt;y^3$</p><p>$\therefore x&gt;y$</p><p>我们设 $x=y+k\ (k为正整数)$，带入式子可得：</p><p>$(y+k)^3-y^3=N$ </p><p>此时出现了两个 $y^3$ 项，我们展开式子将它消掉。</p><p>$y^3+3y^2k+3yk^2+k^3-y^3=N$</p><p>$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 3y^2k+3yk^2+k^3=N$</p><p>然后可以发现，$1\leq k\leq \sqrt[3]{N}$。</p><p>这个范围 $k$ 是可以枚举的，最大到 $10^6$ 。</p><p>并且发现式子具有单调性，尝试二分 $y$。</p><p>当 $k=1$ 时，有 $y$ 最大值 $\sqrt{N}=10^9$。</p><p>$\log{10^9} \approx 10^3$ 可以接受。</p><p>但是 $3y^2k+3yk^2+k^3=N$ 的左边可能会爆 <code>long long</code> ，所以左右两边同时除以一个 $k$。即 $3y^2+3yk+k^2=\frac{N}{k}$。</p><h2 id="方法提炼"><a href="#方法提炼" class="headerlink" title="方法提炼"></a>方法提炼</h2><p>做数学题，有时候看似无法继续推导，实际上是因为没有把隐藏的条件用上。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ull n;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">f</span><span class="params">(ull y,ull k)</span> </span>&#123;<span class="keyword">return</span> <span class="number">3</span>*y*y<span class="number">+3</span>*y*k+k*k;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(ull k=<span class="number">1</span>;k&lt;=<span class="number">1e6</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%k) <span class="keyword">continue</span> ;</span><br><span class="line">        n/=k;</span><br><span class="line">        ull l=<span class="number">1</span>,r=<span class="number">1e9</span><span class="number">+10</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            ull mid=(l+r<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">f</span>(mid,k)&gt;n) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(l,k)==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%llu %llu&quot;</span>,l+k,l);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n*=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC403D] Forbidden Difference</title>
      <link href="/2025/08/23/%5B%E9%A2%98%E8%A7%A3%5D%5BABC403D%5D%20Forbidden%20Difference/"/>
      <url>/2025/08/23/%5B%E9%A2%98%E8%A7%A3%5D%5BABC403D%5D%20Forbidden%20Difference/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC403D-Forbidden-Difference"><a href="#题解-ABC403D-Forbidden-Difference" class="headerlink" title="[题解][ABC403D] Forbidden Difference"></a>[题解][ABC403D] Forbidden Difference</h1><p>原题链接：<a href="https://atcoder.jp/contests/abc403/tasks/abc403_d">D - Forbidden Difference</a>。</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>在长度为 $N$ 的 $A$ 序列中，删除几个元素，使得每一组 $i$ 和 $j$ 满足： $\lvert A_i-A_j\rvert \not= D\ (i&lt;j)$ ，求最少删除几个元素。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><ul><li>$1 \leq N \leq 2 \times 10^5$</li><li>$0 \leq D \leq 10^6$</li><li>$0 \leq A_i \leq 10^6$</li><li>输入中的所有值均为整数</li></ul><h2 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h2><p>题目的约束条件看起来很诡异，我们可以把它理解为：任意两个数的差不能为 $D$ 。</p><p>我们想，一个数 $X$，若存在 $X+D$ 这个数，那么就要删除 $X$ 或 $X+D$ 中的任意一个。但删除了 $X+D$ 后，$X+2D$ 可能也受影响，数据之间相互牵连，显然贪心无解。</p><p>但我们又注意到，$X$ 这个数只与 $X+kD$ 这几个数有关系，和其他的数都无关。因此，我们可以把 $A$ 序列中的数按照 $mod\ D$ 的<strong>余数</strong>分成<strong>互不干扰</strong>的几组，并对每组进行<strong>动态规划</strong>求解答案。</p><p>我们对每组数进行<strong>升序排序</strong>，然后将组内每个数都除以 $D$。此时问题就转化为了：使得当前组中，<strong>不存在相邻两数</strong>的最少操作次数。</p><p>定义 $dp[i][0/1]$ 为：前 $i$ 个数中，有无删除第 $i$ 个数，满足条件的最少操作次数。</p><p>动态转移方程很好推出来，分三类讨论 ($X_i$ 是分组且除以 $D$ 后的序列)</p><ul><li><p>当 $X_i=X_{i-1}$ 时：</p><p>  $dp[i][0]=dp[i][0]$<br>  $dp[i][1]=dp[i][1]+1$ </p></li><li><p>当 $X_i=X_{i-1}+1$ 时(相邻时)：</p><p>  $dp[i][0]=dp[i-1][1]$<br>  $dp[i][1]=\min(dp[i-1][0],dp[i-1][1])+1$</p></li><li><p>其他情况：</p><p>  $dp[i][0]=min(dp[i-1][0],dp[i-1][1])$<br>  $dp[i][1]=min(dp[i-1][0],dp[i-1][1])+1$</p></li></ul><p>每组的花费为 $\min(dp[\lvert X \rvert][0],dp[\lvert X \rvert][1])$。最后将每组花费累加即可。</p><h2 id="方法提炼"><a href="#方法提炼" class="headerlink" title="方法提炼"></a>方法提炼</h2><p>分组的思想。当某个数只对某种条件下的其他数能对答案有贡献时，可以将这些数分组，并在每组上求解。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>,maxd=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,d,ans;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">b</span>(maxd,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=b[x].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+10</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[x][i]-b[x][i<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>])<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[x][i]-b[x][i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>])<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[n][<span class="number">0</span>],dp[n][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=a[i<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        b[a[i]%d].<span class="built_in">push_back</span>(a[i]/d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d;i++) ans+=<span class="built_in">f</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素欧几里得算法 以及 扩展欧几里得算法</title>
      <link href="/2025/08/23/%E6%9C%B4%E7%B4%A0%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/23/%E6%9C%B4%E7%B4%A0%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="朴素欧几里得算法-以及-扩展欧几里得算法"><a href="#朴素欧几里得算法-以及-扩展欧几里得算法" class="headerlink" title="朴素欧几里得算法 以及 扩展欧几里得算法"></a>朴素欧几里得算法 以及 扩展欧几里得算法</h1><h2 id="朴素欧几里得算法"><a href="#朴素欧几里得算法" class="headerlink" title="朴素欧几里得算法"></a>朴素欧几里得算法</h2><p><strong>朴素</strong>欧几里得算法用于求解两个数的最大公因数 <code>gcd</code>。其基于一个巧妙的数学原理：</p><blockquote><p>$\gcd(a,b)=\gcd(b,a\ mod\ b)$</p></blockquote><p>来证明一下这个等式的正确性。</p><p>我们假设 $d= \gcd(a,b)$。<br>那么就有：$a=pd\ ,\ b=qd$。</p><p>注意到 $a\ mod\ b$ 实际上可以表示为 $a-kb\ (k=\lfloor \frac{a}{b} \rfloor)$。也就是 $pd-kqd=d(p-kq)$ 。仍然保留了最大公因数 $d$。</p><p>当 <code>b==0</code> 时，gcd毫无疑问就是<code>a</code> 。</p><p>欧几里得算法本质上就是在<strong>保证最大公因数不变的情况下</strong>，不断缩减两个数的大小，直至一个数为0。</p><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>扩展欧几里得算法实际上就是在求形如</p><blockquote><p>$ax+by=\gcd(a,b)$</p></blockquote><p>的方程的一组解。</p><p>$\because \gcd(a,b)=\gcd(b,a\ mod\ b)$<br>$\therefore ax+by=bx’+(a\ mod\ b)y’$<br>$\therefore ax+by=bx’+(a-\lfloor\frac{a}{b} \rfloor b)y’$<br>$\therefore ax+by=ay’+bx’-\lfloor\frac{a}{b}\rfloor by’$<br>$\therefore ax+by=ay’+b(x’-\lfloor\frac{a}{b}\rfloor y’)$<br>$\therefore x=y’,y=x’-\lfloor\frac{a}{b}\rfloor y’$</p><p>然后我们确定一下边界。</p><p>当 $b=0$ 时，$x=1$，$b$ 可以为任意整数，但通常取 $0$。</p><p>我们可以使用扩展欧几里得算法求某数逆元。</p><p>当 $b=1$ 时，原方程变为 $ax+ay=1$。</p><p>此时两边再同时 $mod\ b$ ，原方程变为 $ax \equiv 1 \pmod{b}$。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,p;</span><br><span class="line"></span><br><span class="line">void exgcd(int a,int b,int &amp;x,int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    if(!b) x=1,y=0;</span><br><span class="line">    else exgcd(b,a%b,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //求逆元</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        exgcd(i,p,x,y);</span><br><span class="line">        x=(x%p+p)%p;</span><br><span class="line">        printf(&quot;%d\n&quot;,x);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 逆元 </tag>
            
            <tag> 欧几里得算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC419C] King&#39;s Summit</title>
      <link href="/2025/08/17/%5B%E9%A2%98%E8%A7%A3%5D%5BABC419C%5D%20King&#39;s%20Summit/"/>
      <url>/2025/08/17/%5B%E9%A2%98%E8%A7%A3%5D%5BABC419C%5D%20King&#39;s%20Summit/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC419C-King’s-Summit"><a href="#题解-ABC419C-King’s-Summit" class="headerlink" title="[题解] ABC419C King’s Summit"></a>[题解] ABC419C King’s Summit</h1><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>在网格图上有 $n$ 个点，坐标为表示为 $(R_i\ ,C_i)$ 。在 $1$ 个时间单位内，点可以选择不动，或者往八个相邻的方向移动。求所有点到达同一个点的最少时间。</p><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p>$1 \leq N \leq 2 \times 10^5$</p><p>$1 \leq R_i\ ,C_i\leq 10^9$ </p><h2 id="思路阐述"><a href="#思路阐述" class="headerlink" title="思路阐述"></a>思路阐述</h2><p>首先想到广搜，但数据范围太大，排除，考虑数学方法。</p><p>设最终到达的点坐标为 $(X\ ,Y)$，然后推导一下不难发现：</p><blockquote><p>在八连通无障碍的情况下，两点之间的距离为 $\max(\vert R-X\vert,\vert C-Y\vert)$ 。</p></blockquote><p>于是最终的答案就可以表示为：$\max\limits_{i=1,2,…,N}(\max(\vert R_i-X\vert,\vert C_i-Y\vert))$</p><p>观察这个式子不难发现，对答案可能有贡献的点只有四个：$R_{max}\ ,R_{min}\ ,C_{max}\ ,C_{min}$ 。</p><p>于是答案又可以转化为：$\max(\vert R_{max}-X\vert,\vert R_{min}-X\vert,\vert C_{max}-Y\vert,\vert C_{min}-Y\vert)$</p><p>因为我们要使得答案最小，所以我们最终选择的 $X$ 到两边的距离应尽量平均。</p><p>此时在 $X$ 轴上花费的最小时间就是：$\lceil \frac{R_{max}-R_{min}}{2}\rceil$ 。</p><p>向上取整保证在最小时间内可以到达 $R_{max}$ 与 $R_{min}$ 。</p><p>在 $Y$ 轴上花费的时间同理，为：$\lceil \frac{C_{max}-C_{min}}{2}\rceil$。</p><p>答案即为：$\max(\lceil \frac{R_{max}-R_{min}}{2}\rceil,\lceil \frac{C_{max}-C_{min}}{2}\rceil)$。</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>在看到数学式子中带有 $max$ 与 $min$ 时，可以考虑一下对式子答案有贡献的点是哪些。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,mx,my,mix=INT_MAX,miy=INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> r,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);</span><br><span class="line">        mx=<span class="built_in">max</span>(r,mx),my=<span class="built_in">max</span>(c,my);</span><br><span class="line">        mix=<span class="built_in">min</span>(mix,r),miy=<span class="built_in">min</span>(miy,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>((mx-mix<span class="number">+1</span>)/<span class="number">2</span>,(my-miy<span class="number">+1</span>)/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$O(N)$ 复杂度，十分高效。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC410F] Balanced Rectangles</title>
      <link href="/2025/08/08/%5B%E9%A2%98%E8%A7%A3%5D%5BABC410F%5D%20Balanced%20Rectangles/"/>
      <url>/2025/08/08/%5B%E9%A2%98%E8%A7%A3%5D%5BABC410F%5D%20Balanced%20Rectangles/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-ABC410F-Balanced-Rectangles"><a href="#题解-ABC410F-Balanced-Rectangles" class="headerlink" title="[题解][ABC410F] Balanced Rectangles"></a>[题解][ABC410F] Balanced Rectangles</h1><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给你一个 $H\times W$ 的网格，仅由 <code>#</code> 和 <code>.</code> 组成。</p><p>统计矩形中 <code>#</code> 与 <code>.</code> 数量相等的矩形数量。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><ul><li><p>$1 \leq T \leq 25000$</p></li><li><p>$1 \leq H,W$</p></li><li><p>所有的 $H\times W$ 的总和不超过 $3\times 10^5$</p></li></ul><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>很自然地发现这是一道枚举题。先来分析一下数据范围。</p><p>根据题目给到的数据范围，基本可以确定时间复杂度是 $O(H^2W)$ 或 $O(W^2H)$。</p><p>但由于 $H\times W$ 的最大值不超过 $3 \times 10^5$ ，所以 $\min_{H,W} \leq \sqrt{3\times 10^5}$  。</p><p>所以本题正解的时间复杂度级大概率是 $O(\min_{H,W}\times\max_{H,W})$ 。</p><p>为了方便，我们假设 $H\leq W$ 。并将 <code>#</code> 当作 $1$，将 <code>.</code> 当作 $-1$，这样如果这个矩形所有点加起来的和为 $0$ ，那么其中 <code>#</code> 和 <code>.</code> 的数量一定相同。</p><p>在 $O(H^2W)$ 的时间复杂度下，我们可以想到的枚举方案：</p><ol><li><p>花费 $H\times W$ 的时间，枚举每个点，问题就转化成了：在 $O(H)$ 的时间里计算以枚举点为右上点的矩形中，满足约束的有多少个。唯一能想到的方法是枚举左下点，但这样的时间复杂度不是 $O(H)$，而是 $O(HW)$ 。</p></li><li><p>花费 $W$ 的时间，枚举长，问题就转换成了：在 $O(H^2)$ 的时间里计算高为 $H$ 长为 $W$ 的矩形里，有多少个长为 $W$ 且满足约束的矩形。貌似解决不了，会有枚举不到的点。</p></li><li><p>花费 $H^2$ 的时间，枚举上界 $up$ 和下界 $dn$，问题就转化成了：在 $O(W)$ 的时间里计算宽为 $dn-up+1$，长为 $W$ 的矩形中，有多少个宽为 $dn-up+1$ 且满足约束的矩形。我们发现矩形的宽都是一样的，那我们就可以使用前缀和进行<strong>降维</strong>。</p><p>设有一个前缀和数组 $S$，$S_i$ 表示：</p><blockquote><p>从 (up,1) 点到 (dn,i) 点的和 </p></blockquote><p>此时就把矩形转换为一条线。此时我们再花费 $W$ 的时间，枚举线的右边界 $r$，问题就再</p><p>转化成了：在 $O(1)$ 的时间内，求解满足 $S_r-S_{[1,r-1]}$ 的结果为 $0$ 的点的数量。我们使用一个桶，就可以轻松解决这个问题。</p><p>为什么可以使用前缀和降维？因为我们枚举的时候就已经枚举了一个维度——宽度，所以我们只需要关注长度就可以了。</p></li></ol><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>这是一道考枚举的好题。</p><p>本题的难度主要在：</p><ul><li><p>想到将 <code>#</code> 和 <code>.</code> 转化为 $1$ 和 $-1$ 。</p></li><li><p>算出正解的时间复杂度。</p></li><li><p>在考虑枚举方案时想到降维。</p></li></ul><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv=<span class="number">6e5</span><span class="number">+30</span>,eps=<span class="number">3e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> T,h,w;</span><br><span class="line"><span class="type">int</span> cnt[maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;h,&amp;w);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(<span class="built_in">min</span>(h,w)<span class="number">+10</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">max</span>(h,w)<span class="number">+10</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> t;cin&gt;&gt;t;</span><br><span class="line">                <span class="keyword">if</span>(h&lt;=w) a[i][j]=(t==<span class="string">&#x27;#&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> a[j][i]=(t==<span class="string">&#x27;#&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h&gt;w) <span class="built_in">swap</span>(h,w);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(h<span class="number">+10</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w<span class="number">+10</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i][j]=s[i<span class="number">-1</span>][j]+a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i][j]+=s[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=h;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=w;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> v=s[j][k]-s[i<span class="number">-1</span>][k];</span><br><span class="line">                    ans+=cnt[v+eps];</span><br><span class="line">                    cnt[v+eps]++;</span><br><span class="line">                    <span class="keyword">if</span>(v==<span class="number">0</span>) ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=w;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> v=s[j][k]-s[i<span class="number">-1</span>][k];</span><br><span class="line">                    cnt[v+eps]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何完美地AC一道题</title>
      <link href="/2025/08/05/%E5%A6%82%E4%BD%95%E5%AE%8C%E7%BE%8E%E5%9C%B0AC%E4%B8%80%E9%81%93%E9%A2%98/"/>
      <url>/2025/08/05/%E5%A6%82%E4%BD%95%E5%AE%8C%E7%BE%8E%E5%9C%B0AC%E4%B8%80%E9%81%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="如何完美地AC一道题"><a href="#如何完美地AC一道题" class="headerlink" title="如何完美地AC一道题"></a>如何完美地AC一道题</h1><h2 id="做题步骤"><a href="#做题步骤" class="headerlink" title="做题步骤"></a>做题步骤</h2><ol><li><p>读题目，分析样例，用自己的话概括题意。</p></li><li><p><strong>分析数据范围，看看有没有奇怪的范围，并推出正解的时间复杂度。</strong></p></li><li><p><strong>分析题目性质，找到题目的突破口。</strong></p></li><li><p><strong>设计算法，用纸和笔写出算法流程。</strong></p></li><li><p>写代码，调代码，提交。</p></li></ol><p>其中第 $4$ 步可以循环，其他部分需要保证<strong>一遍过</strong>！</p><h2 id="分析不出题目性质怎么办？"><a href="#分析不出题目性质怎么办？" class="headerlink" title="分析不出题目性质怎么办？"></a>分析不出题目性质怎么办？</h2><p>以下方法按照<strong>实用性从大到小排序</strong>：</p><ol><li><p>设出题目的答案，根据答案性质<strong>反推</strong>答案（正难则反）。</p></li><li><p>对答案没有贡献的点，直接跳过！</p></li><li><p>善于发现题目的<strong>隐含条件</strong>，如大小关系，单调性。</p></li><li><p>从问题<strong>最简单</strong>的情况出发，一步步<strong>扩展</strong>到原问题。</p></li><li><p>想想能否根据数据的特殊性<strong>分治</strong>？也许不同数据有不同性质。</p></li><li><p>带着摆烂的心态<strong>把玩样例</strong>，说不定就找到性质了呢？</p></li></ol><h2 id="知道了性质，但无法设计出算法怎么办？"><a href="#知道了性质，但无法设计出算法怎么办？" class="headerlink" title="知道了性质，但无法设计出算法怎么办？"></a>知道了性质，但无法设计出算法怎么办？</h2><p>以下方法按照<strong>实用性从大到小排序</strong>：</p><ol><li><p>根据题目的<strong>关键词</strong>，来<strong>大致</strong>确定算法：</p><ul><li><p>最值问题：贪心、动态规划、二分、ST表、线段树。</p></li><li><p>图：最短路、并查集(连通性)、最小生成树。</p></li><li><p>树：树形DP、贪心。</p></li></ul></li><li><p>尝试<strong>枚举</strong>一些变量，将问题拆解。</p></li></ol><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于题目 [ABC409E] Pair Annihilation 的思路梳理</title>
      <link href="/2025/08/04/%E5%AF%B9%E4%BA%8E%E9%A2%98%E7%9B%AE%20%5BABC409E%5D%20Pair%20Annihilation%20%E7%9A%84%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/"/>
      <url>/2025/08/04/%E5%AF%B9%E4%BA%8E%E9%A2%98%E7%9B%AE%20%5BABC409E%5D%20Pair%20Annihilation%20%E7%9A%84%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="对于题目-ABC409E-Pair-Annihilation-的思路梳理"><a href="#对于题目-ABC409E-Pair-Annihilation-的思路梳理" class="headerlink" title="对于题目 [ABC409E] Pair Annihilation 的思路梳理"></a>对于题目 [ABC409E] Pair Annihilation 的思路梳理</h1><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>有一颗 $N$ 个顶点的树，每个顶点上都有一个点权 $P$，保证树上所有点权和为 $0$ 。有 $N-1$ 条边，每条边都有一个边权 $W$。在边上，可以花费 $P\times W$ 个能量使得点权 $P$ 从一个点转移到另一个点，求当所有点上的点权都为 $0$ 时，所花费的最小能量值。</p><h2 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h2><p>我们枚举一个点，将它作为所有点权的终点——每个点权都必须转移到这个地方。</p><p>如何计算转移的总和？设 $P[i]$ 为以 $i$ 为根的树的点权总和(包括根)，设 $dp[i]$ 为：以 $i$ 为根的树上的所有点通过与父亲节点合并的方式，到达点 $i$ 所花费的能量值。如果可以保证 $dp[children]$ 最优，那么 $dp[father]$ 一定是最优的。动态规划的转移方程就是：</p><p>$P[u]=\sum{P[v]}$</p><p> $dp[u]= \sum{dp[v]+\lvert P[v] \rvert\times W}$</p><p>其中，$v$ 表示节点 $u$ 的孩子节点。</p><p>那么我们换一下根，每次的花费就是 $dp[root]$，取其中的最小值就可以得到答案了。</p><p>如何证明其正确性？</p><p>疑惑点就在于，如何保证在以 $i$ 为根的树下，$dp[i]$ 一定是最小花费？</p><p>我们可以举出反例：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7rofms4a.png" alt="反例"></p><p>此时在以 $1$ 为根的子树下，最优的点是 $3$ 而不是根。故 $dp[root]$ 并不是最优。</p><p>但这题我们为什么AC了呢？？？</p><p>这是因为，当整个子树点权和为 $0$ 时，$dp[root]$ 是最优的。</p><p>因为就算 $dp[root]$ 不是最优的，它的点权和都是 $0$ 了，从那个最优点直接移动到 $dp[root]$ 是不用花费能量的。</p><p>因此 $dp[root]$ 一定是最优的，甚至不用换根。</p><p>但这么思考显然有些歪打正着的意味，我们换一种思考方式。</p><p>我们不关注根，而是关注最简单最好处理的<strong>叶子节点</strong>。</p><p>我们发现对于每一个叶子节点，想让它上面的点权变为 $0$ ，一定要花费 $PW$ 个能量，否则点权无法转移。但对于叶子节点，<strong>只能</strong>将它们的点权向父节点转移，转移过后，因为父节点不可能再往点权为 $0$ 的孩子转移，所以我们直接将叶子删掉。</p><p>有趣的地方来了，在将所有叶子节点删去后，有一批父节点会成为新的叶子节点，如此循环往复，最后只剩下 $dp[root]$ 一个结点，它无法向上转移。</p><p>我们回过头来看dp定义。</p><blockquote><p>以 i 为根的树上的所有点通过与父亲节点合并的方式，到达点 i 所花费的能量值。</p></blockquote><p>刚好符合，歪打正着。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有趣吧，看似荒谬的结论，背后却有着精妙的原理。</p><p>若不是下定决心要把这道题搞明白，我也不会收获这么多惊喜。</p><p>只要在困难，挫折，焦虑上添加“坚持”这个调味剂，它们就会变成功时的甜点。</p><p>这次的经历告诉我们，在写代码之前，一定要把思路证明清楚，不要在考场上“感性理解”。</p><p>无从下手的时候，可以研究一下最简单的情况。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模</title>
      <link href="/2025/08/04/%E6%A8%A1/"/>
      <url>/2025/08/04/%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="模"><a href="#模" class="headerlink" title="模"></a>模</h1><h2 id="模的定义"><a href="#模的定义" class="headerlink" title="模的定义"></a>模的定义</h2><p>事实上，模本身并不是一个精确的术语，它可以指代很多东西。</p><ul><li><p>$a\ mod{\ b}$ 和 $a \equiv b \pmod{m}$：此时的模是动词，意味 ‘取余数’。</p></li><li><p>模数：是一个正整数。模数m规定了运算结果中整数的范围为(0~m)。例如：<code>模是998244353</code> 中的模就是模数的意思。</p></li><li><p>模运算：这是一整套在<strong>给定模数下对整数进行计算的规则体系</strong>。例如：<code>学习有关模的知识</code> 此时的模就是模运算的意思。</p></li><li><p>模意义：一种抽象的概念。在模意义下，我们关注数的 ‘同余关系’，而不是观察这个数本身是多少。例如：<code>从模的角度看</code> 的模就是模领域的意思。</p></li></ul><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>模运算中的加、减、乘都很简单。</p><ul><li><p>$(a+b)\ mod \ M = (a\ mod\ M+b\ mod\ M)\ mod\ M$</p></li><li><p>$(a-b)\ mod\ M=(a\ mod\ M-b\ mod\ M)\ mod\ M$</p></li><li><p>$(a\times b)\ mod\ M=(a\ mod\ M\times b\ mod\ M)\ mod\ M$ </p></li></ul><p>但是除法就有些特别。在模运算中<strong>不能</strong>直接除，而是要<strong>乘以除数的逆元</strong>。</p><h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>所谓逆元，其实就是在模领域下的倒数，即<strong>一个数乘以它的逆元在模领域下等于1</strong>。</p><p>例如 $a$ 的逆元是 $a^{-1}\pmod{M}$ ，因为 $a\times a^{-1}\equiv1\pmod{M}$ </p><p>那么一个数的逆元怎么求呢？我们可以使用费马小定理。</p><p>费马小定理：若 $p$ 是质数，且 $a$ 不是 $p$ 的倍数，那么可得 $a^{p-1}\equiv1\pmod{p}$</p><p>$\because a^{p-1} \equiv 1\pmod{p} \\\therefore a\times a^{p-2} \equiv 1\pmod{p}$</p><p>根据逆元定义，可知 $a^{p-2}$ 就是 $a$ 的逆元，接下来再用快速幂求解一下就好了。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 费马小定理 </tag>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WA题铭</title>
      <link href="/2025/08/03/WA%E9%A2%98%E9%93%AD/"/>
      <url>/2025/08/03/WA%E9%A2%98%E9%93%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="WA题铭"><a href="#WA题铭" class="headerlink" title="WA题铭"></a>WA题铭</h1><ol><li><p><a href="https://atcoder.jp/contests/abc416/tasks/abc416_e">E - Development</a>：输入的时候没有取边的min值，而是直接覆盖。以后用邻接表记录图的时候一定要注意！</p></li><li><p><a href="https://atcoder.jp/contests/abc414/tasks/abc414_e">E - Count A%B=C</a>：在带有模的运算中，所有的除都应该变成乘逆元。</p></li><li><p><a href="https://atcoder.jp/contests/abc417/tasks/abc417_e">E - A Path in A Dictionary</a>：多组数据输入时，在每次开始之前要初始化好要用到的东西，不要漏掉！！！</p></li><li><p><a href="https://atcoder.jp/contests/abc409/tasks/abc409_e">E - Pair Annihilation</a>：要注意int类型数据运算时，可能超过int上限，如果不乘1ll,就算记录结果的变量是long long,系统也不会帮你隐式转换！还有就是记清楚自己用的数据是什么类型的，不要犯把long long当成int记的低级错误！还有就是写代码之前一定要把思路证明清楚，不要在模糊的情况下开始写代码！</p></li><li><p><a href="https://atcoder.jp/contests/abc409/tasks/abc409_f">F - Connecting Points</a>：不要在没想清楚的时候写代码！写之前把需要的数据结构、算法都想清楚先，急着写只会损失更多时间；想清楚每个变量，数组的定义，执行完每一步后确保满足定义，不要有模糊的地方，这种地方最容易出错了；代码越长，写的就要越细心！</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数</a>：写变量的数据类型时要小心，注意赋的值的类型。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2657?contestId=249020">P2657 [SCOI2009] windy 数</a>：如果满足了递归退出条件就一定要退出！</p></li><li><p><a href="https://atcoder.jp/contests/abc410/tasks/abc410_f">F - Balanced Rectangles</a>：数组开小了是真难蚌。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P9245">P9245 [蓝桥杯 2023 省 B] 景区导游</a>：求LCA的第二个循环需要从大到小遍历i。</p></li><li><p><a href="https://atcoder.jp/contests/abc420/tasks/abc420_d">D - Toggle Maze</a>：广搜模板打错了。。。边界条件太多了，写 <code>continue</code> 会好点。一定要在结点 <code>push</code> 前打标签啊！否则会多次入队。</p></li><li><p><a href="https://atcoder.jp/contests/abc375/tasks/abc375_e">E - 3 Team Division</a>：数组最多开到 $3\times 10^7$。</p></li><li><p><a href="https://atcoder.jp/contests/abc392/tasks/abc392_d">D - Doubles</a>：请检查数组范围。</p></li><li><p><a href="https://atcoder.jp/contests/abc344/tasks/abc344_d">D - String Bags</a>：动态转移方程没错，但是要看清楚转移方程所碰到的边界条件。还有分组背包dp的模板打错了。。。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过题记录(25年8月)</title>
      <link href="/2025/08/03/%E8%BF%87%E9%A2%98%E8%AE%B0%E5%BD%95(25%E5%B9%B48%E6%9C%88)%20/"/>
      <url>/2025/08/03/%E8%BF%87%E9%A2%98%E8%AE%B0%E5%BD%95(25%E5%B9%B48%E6%9C%88)%20/</url>
      
        <content type="html"><![CDATA[<h1 id="过题记录-25年8月"><a href="#过题记录-25年8月" class="headerlink" title="过题记录(25年8月)"></a>过题记录(25年8月)</h1><ol><li><p>正难则反，从终点开始dp：<a href="https://atcoder.jp/contests/abc415/tasks/abc415_e">E - Hungry Takahashi</a> 。</p></li><li><p>正难则反，判断网格图上[1,1]能否到达[n,m]，可以反过来想障碍物有没有连成一条线把两个点分开在独立的两部分：<a href="https://atcoder.jp/contests/abc413/tasks/abc413_g">G - Big Banned Grid</a> 。</p></li><li><p>翻转[a,b]，翻转[b+1,c]，翻转[a,c] = 交换[a,b]，[b+1,c]的位置(a&lt;b&lt;c)：<a href="https://atcoder.jp/contests/abc413/tasks/abc413_e">E - Reverse 2^i</a></p></li><li><p>搜索时的vis标签可以充分发挥想象，要记住vis数组实际上是标记一种状态可不可行：<a href="https://atcoder.jp/contests/abc410/tasks/abc410_d">D - XOR Shortest Walk</a>。</p></li><li><p>涉及到状态之间的转移与可达性时，考虑建图：<a href="https://atcoder.jp/contests/abc412/tasks/abc412_c">C - Giant Domino</a> 。</p></li><li><p>按值域分治的小trick，第一次见，很新颖：<a href="https://atcoder.jp/contests/abc417/tasks/abc417_d">D - Takahashi&#39;s Expectation</a> 。</p></li><li><p>floyd算法加边比加点简单；如果一个点要与多个点连接，且这几个点之间的距离都相同，我们可以考虑设置一个虚点，然后让所有这样的点与虚点连一条w/2的边，这等价于一个点要与多个点连接一条边权w的边：<a href="https://atcoder.jp/contests/abc416/tasks/abc416_e">E - Development</a> 。</p></li><li><p>多个变量互相牵制的数学题，首先根据其他变量可以确定另一个变量，然后选择一个好枚举的变量作为突破口，这种题的核心不是<strong>怎么算</strong>，而是怎么<strong>加快算的速度</strong>；本题还用到了整数分块的方法优化：<a href="https://atcoder.jp/contests/abc414/tasks/abc414_e">E - Count A%B=C</a> 。</p></li><li><p>字典序的从小到大输出可以用贪心+深搜解决：<a href="https://atcoder.jp/contests/abc417/tasks/abc417_e">E - A Path in A Dictionary</a> 。</p></li><li><p>对题目无从下手的时候可以试试枚举一个量啊！对题目无从下手的时候可以试着研究一下最简单情况啊！：<a href="https://atcoder.jp/contests/abc409/tasks/abc409_e">E - Pair Annihilation</a> 。</p></li><li><p>要善用数据结构，在以后碰到最大最小值的时候优先考虑优先队列，还有并查集不要再给我写错了：<a href="https://atcoder.jp/contests/abc409/tasks/abc409_f">F - Connecting Points</a> 。</p></li><li><p>[数位dp专题]首次尝试数位dp的记搜写法，超级好用，强推：<a href="https://www.luogu.com.cn/problem/P4999?contestId=249020">P4999 烦人的数学作业</a> 。</p></li><li><p>[数位dp专题]注意是刚好满足：<a href="https://www.luogu.com.cn/problem/P8764?contestId=249020">P8764 [蓝桥杯 2021 国 BC] 二进制问题</a> 。</p></li><li><p>[数位dp专题]有前导零和无前导零的状态要分开算，dp值也要分开记录：<a href="https://www.luogu.com.cn/problem/P2602?contestId=249020">P2602 [ZJOI2010] 数字计数</a> 。</p></li><li><p>[数位dp专题]考察对数位dp的掌握程度：<a href="https://www.luogu.com.cn/problem/P2657?contestId=249020">P2657 [SCOI2009] windy 数</a> 。</p></li><li><p>一道枚举好题；没思路可以先推出正解时间复杂度，然后尝试枚举方案；可以把字符转换成数字，来判断字符数量相等；在枚举某个维度的情况下，每个case里不需要考虑枚举的那个维度：<a href="https://atcoder.jp/contests/abc410/tasks/abc410_f">F - Balanced Rectangles</a> 。</p></li><li><p>在数学式子中带有 $max$ 与 $min$ 时，可以想想哪些点对答案有贡献：<a href="https://atcoder.jp/contests/abc419/tasks/abc419_c">C - King’s Summit</a> 。</p></li><li><p>分治思想。分成几组互不影响的组，并分别求解计算：<a href="https://atcoder.jp/contests/abc403/tasks/abc403_d">D - Forbidden Difference</a> 。</p></li><li><p>善于发现隐含条件：<a href="https://atcoder.jp/contests/abc420/tasks/abc420_d">D - Toggle Maze</a>。</p></li><li><p>设出答案，推出答案性质，利用性质反推答案：<a href="https://atcoder.jp/contests/abc393/tasks/abc393_e">E - GCD of Subset</a>。</p></li><li><p>大胆设状态：<a href="https://atcoder.jp/contests/abc375/tasks/abc375_e">E - 3 Team Division</a>。</p></li><li><p>好好读题：<a href="https://atcoder.jp/contests/abc392/tasks/abc392_d">D - Doubles</a>。</p></li><li><p>简单分组背包：<a href="https://atcoder.jp/contests/abc344/tasks/abc344_d">D - String Bags</a>。</p></li><li><p>对答案没有贡献的点，直接跳过！：<a href="https://www.luogu.com.cn/problem/P1840">P1840 Color the Axis - 洛谷</a>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> 过题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC417D] Takahashi&#39;s Expectation</title>
      <link href="/2025/08/03/%5B%E9%A2%98%E8%A7%A3%5D%5BABC417D%5D%20Takahashi&#39;s%20Expectation/"/>
      <url>/2025/08/03/%5B%E9%A2%98%E8%A7%A3%5D%5BABC417D%5D%20Takahashi&#39;s%20Expectation/</url>
      
        <content type="html"><![CDATA[<h1 id="题解-AtCoder-Beginner-Contest-417-D-Takahashi’s-Expectation"><a href="#题解-AtCoder-Beginner-Contest-417-D-Takahashi’s-Expectation" class="headerlink" title="(题解)[AtCoder Beginner Contest 417] D - Takahashi’s Expectation"></a>(题解)[AtCoder Beginner Contest 417] D - Takahashi’s Expectation</h1><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>完整题面：<a href="https://atcoder.jp/contests/abc417/tasks/abc417_d">原题链接</a>。</p><p>有 $Q$ 个问题，每个问题给出一个初始值 $X$。$X$ 要依次经过 $N$ 次变化，对于每次变化：</p><p>若 $P_i \geq X$，则 $X + A_i$ $(1 \leq i \leq N)$</p><p>若 $P_i &lt; X$，则 $X - B_i$ $(1 \leq i \leq N)$</p><p>输出 $Q$ 行，每行输出 $X$ 经过 $N$ 次变换后的值。</p><p>数据范围：</p><p>$1 \leq N \leq 10000$</p><p>$1 \leq Q \leq 5 \times 10^5$</p><p>$0 \leq X \leq 10^9$</p><p>$1 \leq P_i, A_i, B_i \leq 500$</p><h2 id="思路阐述"><a href="#思路阐述" class="headerlink" title="思路阐述"></a>思路阐述</h2><p>首先很容易想到一个 $O(NQ)$ 的做法。对于每一个 $X$，依次进行 $N$ 次变化。</p><p>但这样的操作有很多冗余的部分，因为在 $P_i &lt; X$ 时，$X$ 一直在下降 $B_i$，每次下降的步长很少，而 $P_i$ 又远远小于 $X$，进而导致了在很长一段时间中都在重复地减 $B_i$ 。——这并不优雅，违背了 <em>Science is elegant</em> 原则，需要优化。</p><p>我们可以使用前缀和+二分来优化一下这个减 $B_i$ 的过程。设数组 $Sum$ 是数组 $B$ 的前缀和数组，二分找到第一个使 $X - Sum_i \leq 500$ 的 $Sum_i$，并让 $X - Sum_i$，此举使得 $X$ 能快速接近 $P_i$。PS：边界为 $500$ 的原因是 $P_i$ 最大就是 $500$。</p><p>把 $X$ 的值缩减至 $500$ 附近就很好办了，我们可以倒着预处理一个 $dp_{i,j}$ 表示：初始值为 $j$，从第 $i$ 次操作开始执行，最后的值是多少。如何确定 $j$ 的范围呢？因为 $P_i + A_i$ 的值最多为 $1000$，所以 $X$ 在缩减至 $500$ 附近之后的大小也最多为 $1000$，而 $j$ 又是为 $X$ 服务的，所以 $j$ 最多为 $1000$。</p><p>注意 dp 在转移的时候需要 $i$ 需要倒序遍历。由于转移方程与 dp 边界并不是本题难点，这里就不给出了，请读者自行思考。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],p[maxn],sum[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1000</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[n]&gt;=j) dp[n][j]=j+a[n];</span><br><span class="line">        <span class="keyword">else</span> dp[n][j]=<span class="built_in">max</span>(<span class="number">0</span>,j-b[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1000</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]&gt;=j) dp[i][j]=dp[i<span class="number">+1</span>][j+a[i]];<span class="comment">//满足此条件时j必定小于等于500,所以j+a[i]&lt;=1000，不会越界</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">+1</span>][<span class="built_in">max</span>(<span class="number">0</span>,j-b[i])];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,p+i,a+i,b+i);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DP</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][x]);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时 x &gt; 1000, 每次选礼物的时候心情都必定降低，所以要使 x &lt;= 1000, 只需要减去 b[pos] 的前缀和就可以了</span></span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">lower_bound</span>(sum<span class="number">+1</span>,sum<span class="number">+1</span>+n,x<span class="number">-1000</span>)-sum;<span class="comment">// x - sum &lt;= 1000 ----&gt; x &lt;= 1000 + sum -----&gt; x - 1000 &lt;= sum</span></span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x-sum[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x-=sum[pos];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[pos<span class="number">+1</span>][x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC408D] Flip to Gather</title>
      <link href="/2025/06/01/%5B%E9%A2%98%E8%A7%A3%5D%5BABC408D%5D%20Flip%20to%20Gather/"/>
      <url>/2025/06/01/%5B%E9%A2%98%E8%A7%A3%5D%5BABC408D%5D%20Flip%20to%20Gather/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，每次可以将 $0$ 改为 $1$，将 $1$ 改为 $0$。现想让这个字符串上所有的 $1$ 连在一起，求最小操作次数。</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>最小操作次数，考虑 DP。</p><p>设 $dp[i][j][k]$ 表示：<strong>将原字符串</strong>的前 $i$ 位改为以 $j$（$j$ 为 $0$ 或 $1$）结尾，且有连续的 $1$ 存在（$k$ 为 $1$ 表示存在）的字符串的最小操作次数。</p><p>然后推导状态转移方程。</p><p>首先 $dp[i][1][0]$ 是不满足状态定义的，无需讨论。因为它既然以 $1$ 结尾，那么一定会有连续的 $1$ 存在。</p><p>然后看 $dp[i][0][0]$，根据定义，可以得出变化后的字符串长这个样子：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9fudwvt6.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="dpi00png"></p><p>看图可以轻松得出：$dp[i][0][0]=dp[i-1][0][0]+[s_i为1]$。</p><p>然后看 $dp[i][0][1]$ 的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g1mp3cpi.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="dpi01png"></p><p>同样：$dp[i][0][1]=min(dp[i-1][0][1],dp[i-1][1][1])+[s_i为1]$。</p><p>最后看 $dp[i][1][1]$ 的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/15b4lo1j.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="dpi11png"></p><p>同样：$dp[i][1][1]=min(dp[i-1][0][0],dp[i-1][1][1])+[s_i为0]$。</p><p>值得注意的是 $dp[i][1][1]$ 无法被 $dp[i][0][1]$ 转移，因为这样的 $1$ 不是连续的。</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=s[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s1=s[i]==<span class="string">&#x27;1&#x27;</span>,s0=s[i]==<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+s1;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>])+s1;</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>])+s0;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>]))&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC407C] Security 2</title>
      <link href="/2025/05/27/%5B%E9%A2%98%E8%A7%A3%5D%5BABC407C%5D%20Security%202/"/>
      <url>/2025/05/27/%5B%E9%A2%98%E8%A7%A3%5D%5BABC407C%5D%20Security%202/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>在一个空串末尾添加 $ 0 $ 或将空串上的数字全部加上 $1$ ，满 $10$ 退回 $0$ ，求将空串变为目标串 $S$ 所需最小操作次数。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑贪心。</p><p>我们先把<strong>空串</strong>变为都是 $0$ 的<strong>操作</strong>串，并且遍历<strong>目标串</strong>。</p><p>由此可得，题目的添加操作就相当于</p><blockquote><p>将 $[1,i]$ 中每一个数加 $1$ </p></blockquote><p>由此不难发现，当目标串呈<strong>单调递减</strong>时，所需的最小操作步数为<strong>目标串中最大的数</strong>。如当前目标串为 $94221$ ，所需最小操作次数就为   $9+5=14$ 。（别忘了加 $0$ 也要加次数）</p><p>这样我们就可以把目标串分为<strong>很多个单调递减的序列</strong>。</p><p>但要是 $S_i$ <strong>不属于</strong>上一个单调递减的序列呢？比如当前目标串是 $527$ 。我们遍历到了第三位，想让最低位为 $7$ ，不可避免的就要将 $[1,3]$ 区间内所有数加上 $7$ ，可我们 $[1,2]$ 区间内的数已经处理好了，我们不想改变它，怎么办呢？</p><p>根据题目满 $10$ 归 $0$ 的性质，可以得出</p><blockquote><p>任何一个数加上了10，都可以回到原来那个数。</p></blockquote><p>那这样就好办了，又要将 $[1,3]$ 加上 $7$ ，又要 $[1,2]$ 不变，那么先 $[1,2]$ 加上 $3$ ，再让 $[1,3]$ 加上 $7$ 就好了嘛。这样 $[1,2]$ 总共加了 $10$ 保持不变，且总共操作了 $10$ 次，将操作次数加上 $10$ 就好啦。</p><p>也就是说，当 $S_i\leq S_{i-1}$ 时，满足单调递减，就不用增加操作次数；当 $S_i&gt;S_{i-1} $ 时，是新递减序列的开头，需要加上 $10$ 使得操作串与目标串统一。</p><h1 id="简洁的代码"><a href="#简洁的代码" class="headerlink" title="简洁的代码"></a>简洁的代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans,l=INT_MAX,n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cin&gt;&gt;s;</span><br><span class="line"> n=s.<span class="built_in">size</span>();</span><br><span class="line"> ans+=n;</span><br><span class="line"> ans+=s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> t=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span>(t&gt;l) ans+=<span class="number">10</span>;</span><br><span class="line"> l=t;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LCA算法笔记][题解][P9245 蓝桥杯 2023 省B] 景区导游</title>
      <link href="/2025/04/26/%5B%E9%A2%98%E8%A7%A3%5D%5BLCA%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%5D%5BP9245%20%E8%93%9D%E6%A1%A5%E6%9D%AF%202023%20%E7%9C%81B%5D%20%E6%99%AF%E5%8C%BA%E5%AF%BC%E6%B8%B8/"/>
      <url>/2025/04/26/%5B%E9%A2%98%E8%A7%A3%5D%5BLCA%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%5D%5BP9245%20%E8%93%9D%E6%A1%A5%E6%9D%AF%202023%20%E7%9C%81B%5D%20%E6%99%AF%E5%8C%BA%E5%AF%BC%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>本文分为两个部分，一是介绍倍增法求LCA（最近公共祖先），二是回归题目的题解。</p><h1 id="倍增法求LCA"><a href="#倍增法求LCA" class="headerlink" title="倍增法求LCA"></a>倍增法求LCA</h1><h2 id="实现过程及原理"><a href="#实现过程及原理" class="headerlink" title="实现过程及原理"></a>实现过程及原理</h2><p>（为方便读者理解，本小节暂不探讨如何实现代码，只谈算法思路。具体实现细节见下小节。）</p><p>在一个树上有两个结点 $u$ 和 $v$ ，$dep_i$ 表示从根结点到 $i$ 的距离， $dep_u&gt;dep_v$ ，求 $lca(u,v)$。</p><p>大致思路是先将 $u$ 和 $v$ <strong>移至同一层</strong>，再<strong>同时</strong>将两个结点向<strong>上移</strong>，直到相同为止。（上移一层指将 u 更新为他的父结点 。）</p><h3 id="将-u-和-v-提至同一层"><a href="#将-u-和-v-提至同一层" class="headerlink" title="将 $u$ 和 $v$ 提至同一层"></a>将 $u$ 和 $v$ 提至同一层</h3><p>首先需要将 $u$ 和 $v$ 移动到同一层上，也就是将 $u$ 上移 $dep_u-dep_v$ 层。</p><p>设 $k = dep_u-dep_v$ ，则很容易想出将 $u$ 上移 $k$ 次，但这样<strong>效率很低</strong>。如果用 $fa_{u,k}$ 来记录 $u$ 点上移 $k$ 次后的节点，则需要<strong>很多空间</strong>。</p><p>我们采取一个<strong>折中方案</strong>，用 $fa_{i,j}$ 来记录 $i$ 节点上移 $2^i$ 后的结点——恭喜你发现了<strong>倍增法</strong>。</p><p>通过这样一个 $fa_{i,j}$ 数组，我们可以推理出<strong>每一个 $u$ 节点上移 $k$ 层</strong> 后的结点，方法如下：从低位向高位依次遍历 $k$ 的<strong>二进制</strong>，若第 $i$ 位为 $1$ ，则将 $u$ 上移 $2^i$ 层，若为 $0$ 则不做处理。如此遍历完成后， $u$ 点总共便上移了 $k$ 层。如果此时$u=v$ ，那么 $lca(u,v)$ 就是 $v$ 啦。</p><h3 id="同时上移-u-和-v-，直到到达-lca-u-v"><a href="#同时上移-u-和-v-，直到到达-lca-u-v" class="headerlink" title="同时上移 $u$ 和 $v$ ，直到到达 $lca(u,v)$"></a>同时上移 $u$ 和 $v$ ，直到到达 $lca(u,v)$</h3><p>此时的 $u$ 和 $v$ 已经处在同一层，所以 $dep_u$ 等价于 $dep_v$ 。</p><p>注意到，$fa_{u,i}和fa_{v,i}$ 之间（$fa$ 数组里存的是结点编号），只有两种情况：<strong>相同</strong>或<strong>不相同</strong>。如果相同，则说明 $u+2^i = v+2^i$ ，此时结点是它们的<strong>公共祖先</strong>，但<strong>不一定</strong>是最近公共祖先；如果不同，则说明 $fa_{u,i}$ 和 $fa_{v,i}$ 这两个结点的 $dep$ <strong>都小于</strong>他们的<strong>最近公共祖先</strong>。</p><p>我们发现，如果在 $fa_{u,i}=fa_{v,i}$的情况下，将 $u和v$ 结点上移 $2^i$ 层很可能就会<strong>移过头</strong>。但若 $fa_{u,i}\neq fa_{v,i}$ ，将 $u和v$上移 $2^i$ 层，就会<strong>无限逼近</strong>它们的最近公共祖先。</p><p>现在我们依次遍历每一个 $i$ ，从小到大或从大到小都可以，我们从大到小。当 $u+fa_{u,i}\neq v+fa_{v,i}$ 时，我们将 $u$ 和 $v$上移 $2^i$ 层。那么循环结束后，$u和v$ 究竟上移到了哪里呢？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zyam7d1n.png" alt=""></p><p>设距离 $k=dep_{lca(u,v)}-1-dep_u$。如果 $fa_{u,i}=fa_{v,i}$ ，则 $2^i&gt;k$，此时 $k$ 的第 $i$ 位二进制<strong>一定</strong>是 $0$ 。若 $fa_{u,i}\neq fa_{v,i}$ ，则 $2^i\le k$ ，此时 $k$ 的 $i$ 位二进制<strong>一定</strong>是 $1$ 。我们发现，如果在所有 $fa_{u,i}\neq fa_{v,i}$ 时将 $u$ 加上 $2^i$ ，则最后就是<strong>加了 $k$ 的每一位二进制</strong>，也就是总共加了 $k$ 。</p><p>现在我们知道了，这样做到最后一共是上移了 $dep_{lca(u,v)}-1-dep_u$ 层，$dep_u+dep_{lca(u,v)}-1-dep_u=dep_{lca(u,v)}-1$，因此我们<strong>最后到达的地方是 $lca(u,v)$ 下面的一个结点</strong>，所以最后我们要返回这个结点的父节点。</p><h2 id="细节问题探讨"><a href="#细节问题探讨" class="headerlink" title="细节问题探讨"></a>细节问题探讨</h2><h3 id="fa-数组的计算"><a href="#fa-数组的计算" class="headerlink" title="$fa$ 数组的计算"></a>$fa$ 数组的计算</h3><p>采用动态规划的思想，可以先确定边界。$fa_{i,0}$ 是 $i$ 的父节点，这个可以深搜或广搜算。</p><p>然后状态转移方程是 $fa_{i,j}=fa_{fa_{i,j-1},j-1}$ ，说人话就是 $i+2^j=i+2^{j-1}+2^{j-1}$ 。</p><p>画一张图来推导循环先后。下图是一个$fa$ 数组。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lfcqxfl1.png" alt=""></p><p>$fa_{i+2^{j-1},j-1}$ 的位置是只能确定列的，因此我们要一列一列的求，也就是先遍历 $j$ 。</p><h3 id="dep-数组的计算"><a href="#dep-数组的计算" class="headerlink" title="$dep$ 数组的计算"></a>$dep$ 数组的计算</h3><p>深搜或广搜都行，再次不多赘述。</p><h1 id="回归题目"><a href="#回归题目" class="headerlink" title="回归题目"></a>回归题目</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个有 $N$ 个点的有权图中，计算经过$A_1,A_2…A_{i-1},A_{i+1}…A_k$ 这几个点所要的最少时间。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>因为是树上求最短路径，所以想到 $lca$ 。用一个 $S$ 记录经过 $A_1,A_2,…A_k$ 的最短时间，用 $dis_{u,v}$ 表示从 $u$ 到 $v$ 最短时间。之后跳过某个点的时候，在 $S$ 上删掉一些 $dis$，加上一些 $dis$ 就可以了。以样例 $2,6,5,1$ 为例，具体如图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6ltyyw63.png" alt=""></p><p>跳过起点 （跳过2）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rvsq6udd.png" alt=""></p><p>剩下的 “O” 就是 $dis_{6,5} + dis_{5,1}$ 时留下的标记了。</p><p>跳过中间点（跳过6）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ofoph7d5.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9rbynebq.png" alt=""></p><p>剩下的 “O” 就是 $dis_{2,5} + dis_{5,1}$ 时留下的标记了。</p><p>跳过终点（跳过1）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/osfu88vd.png" alt=""></p><p>剩下的 “O” 就是 $dis_{2,6} + dis_{6,5}$ 时留下的标记了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; G[maxn];</span><br><span class="line"><span class="type">int</span> dep[maxn],fa[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> a[maxn],sum[maxn];<span class="comment">// sum[i] 为 1~i的时间 </span></span><br><span class="line"><span class="type">int</span> n,k,s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准lca模板 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(node t:G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==from) <span class="keyword">continue</span> ;</span><br><span class="line">        dep[v]=dep[u]<span class="number">+1</span>;</span><br><span class="line">        fa[v][<span class="number">0</span>]=u;</span><br><span class="line">        sum[v]=sum[u]+t.w;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">20</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="type">int</span> k=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;(<span class="number">1</span>&lt;&lt;i)) u=fa[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            u=fa[u][i];</span><br><span class="line">            v=fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算u到v所需时间 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">if</span>(u&lt;<span class="number">1</span>||v&gt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    u=a[u];</span><br><span class="line">    v=a[v];</span><br><span class="line">    <span class="keyword">return</span> sum[u]+sum[v]<span class="number">-2</span>*sum[<span class="built_in">lca</span>(u,v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">father</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i);</span><br><span class="line">        s+=<span class="built_in">dis</span>(i<span class="number">-1</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,s-<span class="built_in">dis</span>(i<span class="number">-1</span>,i)-<span class="built_in">dis</span>(i,i<span class="number">+1</span>)+<span class="built_in">dis</span>(i<span class="number">-1</span>,i<span class="number">+1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解][ABC393D] Swap to Gather</title>
      <link href="/2025/02/19/%5B%E9%A2%98%E8%A7%A3%5D%5BABC393D%5D%20Swap%20to%20Gather/"/>
      <url>/2025/02/19/%5B%E9%A2%98%E8%A7%A3%5D%5BABC393D%5D%20Swap%20to%20Gather/</url>
      
        <content type="html"><![CDATA[<p>原题链接: <a href="https://atcoder.jp/contests/abc393/tasks/abc393_d">原题面</a></p><h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>你得到一个长度为 N 的字符串 S ，由 0 和 1 组成。保证 S 至少包含一个 1 。<br>您可以执行以下操作任意次数（可能为零）：<br><strong>· 选择一个整数 i （ 1≤i≤N−1 ）并交换 S 的第 i 个和第 (i+1) 个字符。</strong><br>找出使所有 1 连续所需的最小操作数。<br>这里，所有的 1 被称为是连续的，当且仅当存在整数 l 和 r （ 1≤l≤r≤N ），使得 S 的第 l~r之间都是1</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>2≤N≤5×10^5<br>N 是整数。S 是一个长度为<br>N 的字符串，由 0 和 1 组成。<br>S 至少包含一个 1 。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>我们来解读一下题意，题目说要把所有的1放在一起，且只能通过交换相邻两个数的方式移动<br>那么我们假设有一个1要从 i 的位置移动到 j ，毫无疑问，移动次数是 j - i (j ≥ i)，也就是<strong>i 和 j 之间的距离</strong><br>此时一切都变得熟悉，距离，最短移动次数，连续，还记得七年级上册学的，求 |x+1|+|x+2| 这个不等式为最小值时，x的值是多少吗？没错，这道题就是它<strong>几何</strong>解法的变种（虽然我在第一次想的时候也没想出来哈哈哈）<br>事实上，这是一个经典的<strong>仓库选址问题</strong>，其最小值的x一定是在中间的(不懂请看：<a href="https://blog.csdn.net/weixin_52797843/article/details/122069259">货仓选址</a>)<br>但唯一有一点不一样的是，求那个不等式时算的是所有点到x这个点的距离，但本题要求的是所有的1都连续，那么怎么表示这个答案呢？<br>我们假设<strong>x的值是中间的那个1的位置</strong>，那么x左边的第一个1(假设位置为k)需要移动的距离就是x-k-1（只需要移动到相邻的那个位置），x左边第二个1(假设位置为q)需要移动的距离就是x-q-2，见图</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ky1twzs5.png" alt="在这里插入图片描述"><br>我们发现，对于每一个1，它到最终“仓库”的距离是</p><blockquote><p>x-k+<strong>它距离仓库有多少个其他的1</strong></p></blockquote><p>因为每有一个1移动了，下一个1的移动距离就需要<strong>减一个距离单位</strong>(靠在已移动好的那个1旁边)<br>又由于这个字符串只由0或1组成，换句话说，这个字符串要么是0，要么是1<br><strong>如果k到x的距离会因为其中的1而减少，那么统计0的个数就可以了</strong><br>例如，k到x之间有两个0，所以它最少需要移动两步<br>q到x之间有三个0，所以它最少需要移动三步<br>知道了这一点之后，问题就变成了如何确定k与x之间0的个数<br>还是非常简单，类似于初中的线段和差<br>我们记录一下从<strong>0 ~ k中0的个数</strong>，再记录<strong>0 ~ x 中 0 的个数</strong>，两个相减，就得到了<strong>k ~ x中0的个数</strong><br>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,one[<span class="number">1000001</span>];<span class="comment">//&quot;1&quot; 的位置 </span></span><br><span class="line">ll cnt; <span class="comment">//0~k-1中1的个数 </span></span><br><span class="line">ll x;<span class="comment">//仓库的位置 </span></span><br><span class="line">ll ans;</span><br><span class="line">string a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;1&#x27;</span>) one[cnt<span class="number">+1</span>]=i-cnt,cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    x=one[(cnt<span class="number">+1</span>)/<span class="number">2</span>];<span class="comment">//仓库选址，取中位数，1一定是优于0的，所以在1的位置中选中位数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) ans+=<span class="built_in">abs</span>(one[i]-x);<span class="comment">//算k~x 中0的个数，因为x是中位数，一定存在比它大的1的位置，故需要取绝对值 </span></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为什么我在比赛的时候想不出来。。。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Atcoder </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 CSP 游记</title>
      <link href="/2024/10/27/2024%20CSP%20%E6%B8%B8%E8%AE%B0/"/>
      <url>/2024/10/27/2024%20CSP%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>暑假开始买了本信奥一本通，结果都没翻开来看，早知道就听 AMC 的不去买书了 www</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><hr><p>J 组倒是没啥想说的，当时考完的时候还以为能 AK，结果错了几道判断，遗憾 93.5<br>当时还听说小六的 hwz 98，%%%</p><p>S 组也是给我蒙过去了，完善程序第一题考得刚好是我昨晚复习的二分，一看答案五<br>个 A，觉得肯定错了，但也懒得改，没想到答案还真是这样，最后 57.5 拿下</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><hr><p>day 0 考前一天被班上同学全票选上班长（www…我要辞职）<br>结果晚上班级搞大扫除，六点开始的赛前集训我七点才到 后来也就是和其他 Oler 和 教练聊了会天，感觉状态非常好<br>后来就出发去考场旁边的酒店住了一晚（没睡好）</p><h2 id="day1-J"><a href="#day1-J" class="headerlink" title="day1-J"></a>day1-J</h2><hr><p>早上 7：00 起来昏沉沉的，当时就想这次肯定完蛋了，开考前也没太紧张(估计是没睡好所以才不觉得紧张)<br>然后就和其他 Oler 一起去考场等了</p><p>8：30 准时开考，由于是第一次考，一开始忘记了考试题是放在 D 盘里的，还纳闷怎么没有考<br>试文件，结果旁边的女选手也没意识到，还是个 i 人，愣是考了半小时她才说，好在我天资聪慧，想了 2 分钟终于想起来了</p><h3 id="看题"><a href="#看题" class="headerlink" title="看题"></a>看题</h3><hr><p>把四道题扫了一眼，初步判定前 A 题是水题，B 题搜索， C 题动规，D 题应该是个图</p><p>T1 poker</p><p>桶去重秒了，10mins 切了第一题，考完才想起来可以用 set</p><p>T2 explore</p><p>仔细看了题才发现这和搜索没关系，纯纯一送分模拟，20mins 切了</p><p>T3 sticks</p><p>题目让用 n 个火柴棒搭一个最小的数字，然后把每数字需要的火柴棒都给了你<br>读题的时候就觉得这几个特殊性质有意思，但还是没多想，在脑海中抽象了 10 几分钟，啥也没想到<br>没办法，先写了个深搜，突然发现 long long 放不下，直接改了 string（。。。）<br>再后来发现白改了，改了也 TLE，白费 10mins，再后来绞劲脑汁想优化没结果啥都没想到，无奈打表，把 n&lt;=50 的情况全部打出来，发现答案好多 8，才意识到这就是个数学题，结合特殊性质的提示，<br>得出结论： 为了让数字最小，就得让数字位数最小，选择火柴棒根数最多的 8 来搭就能达到这一目的，然后就是相同余 数下的开头两位数不同，其他都是 8，最后为了保险，把 20 以内的数据都放在了数组里，这样就避免了特判， 考完就发现好多人没有注意到 n=17 要特判，嘿嘿 写完这题的时候我那叫一个慌张，觉得这个答案未免太离谱，一堆 8，好在我心里素质强，坚信这是正解，花了 2 小时才切掉这题</p><p>T4 chain</p><p>看完 D 题果断放弃，这不是我可以写出来的（看题都看了半天，一开始看题都看错了，直接怀疑起样例解释）， 甚至爆搜都没有思路，回去检查罚坐了一小时</p><h3 id="最后估计：100-100-100-0-300"><a href="#最后估计：100-100-100-0-300" class="headerlink" title="最后估计：100+100+100+0=300"></a>最后估计：100+100+100+0=300</h3><hr><p>问了一下大家感觉 300 也就是个大众分，不过第一次考我已经很满意了，争取明年 AK！</p><h2 id="day1-S"><a href="#day1-S" class="headerlink" title="day1-S"></a>day1-S</h2><hr><h3 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h3><p>考完 J 组吃完午饭都接近两点了，午觉是一点没睡成，加上晚上没睡好，我还开玩笑和同学说去 S 赛场睡两小时</p><h2 id="看题-1"><a href="#看题-1" class="headerlink" title="看题"></a>看题</h2><hr><p>扫了一眼，觉得 A 题是个背包，B 题模拟+高中物理（加速度），C 题动规，D 题不想看，一看就写不出来（考完 去洛谷看了眼，黑题，好险没浪费时间）<br>T1 duel</p><p>一开始以为是个 01 背包，抽象了一下发现不是，数据范围不大，我直接桶排，然后根据当前项比较上一项，由于此时 每只怪兽数值都是有序的，所以只有两种情况： 1、当前项数量小于上一项，那就直接把上一项替换成当前项，最小剩下总数目不变 2、当前项数量大于上一项，那就直接把剩余数量加上数量之差 20mins 切掉第一题</p><p>T2 detect</p><p>一开始想着 AC 他，花 20mins 写了个 O(nm)的代码，发现读入的数据不对，排了半天错误，结果发现是把 int 数组开成了 bool，在上面花了 60mins，我直接红温，转到 T3<br>过了一会发现 T3 也写不出来，想着回来偷点分<br>然后就看特殊性质，发现 B 和 C 的性质很好拿分 B 和 C 的特殊性质只需要在最后一个检查站判断是否超速就行了，如果没有车辆超速，那就可以把所有检查站撤除，否则就保留最后一个，用时 45mins<br>当时加速度为负数的时候想半天想不到解法，考完试一听见有人说二分就悟了，哎，事后诸葛亮</p><p>T3 color</p><p>看了题，果断选择用二进制表示颜色，暴力搜索，然后过了小样例，后来脑抽换了深搜想优化，结果啥都没优化出来，果断 放弃，用时 20mins</p><h3 id="最后估计：100-40-20-160"><a href="#最后估计：100-40-20-160" class="headerlink" title="最后估计：100+40+20=160"></a>最后估计：100+40+20=160</h3><hr><p>一起学的Oler好像也就是写出来了第一题多一点点，平均水平吧只能说，但是我已经算发挥的很好了 第一次参加 csp，对于这个成绩我已经很满意了，前途无限呀！</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
